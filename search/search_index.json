{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to LokiDB Javascript Quickstart Typescript Quickstart API Reference Check it out . Topics Query Examples Persistence CollectionTransforms Understanding Comparators LokiOperatorPackage Loki Ranged Indexes Getting Started","title":"Home"},{"location":"#welcome-to-lokidb","text":"Javascript Quickstart Typescript Quickstart","title":"Welcome to LokiDB"},{"location":"#api-reference","text":"Check it out .","title":"API Reference"},{"location":"#topics","text":"Query Examples Persistence CollectionTransforms Understanding Comparators LokiOperatorPackage Loki Ranged Indexes","title":"Topics"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"comparators/","text":"Loki Comparators Comparators (in javascript and loki) are functions which accept two values and return : - 0 : if the first and second are considered equal - -1 : if the first is less than the second - 1 : if the first is greater than the second Overview Since comparators now play a important role in customizing and fine-tuning LokiDB, this page will attempt to summarize the reasoning behind this increased structuring. In the previous version of LokiDB (LokiJS), various components such as find ops, BinaryIndices and sorting shared a common set of helper functions serving as a common comparator. This arbitrary co-mingling inadvertently became standard as it would have been too much of a breaking change to decouple that later on (although some attempts to provide additional options were later added). In LokiDB, to support decoupling these various components, we have established a 'ComparatorMap' which is a collection of named comparator functions. LokiDB utilizes these comparators for : - Unindexed sorting - Used with RangedIndexes (such as our provided \"avl\" index) for higher performance filtering. - Can be optionally leveraged within unindexed find() operations (like $eq, $gt, $gte, $lt, $lte, $bewtween) when using our new 'ComparatorOperatorPackage' (See operators.md ). Why would I need more than the default \"js\" comparator? Out of the box, LokiDB provides some base comparators : - \"js\" (default) : fastest, pure javascript with strict equality for $eq - \"abstract-js\": fast, pure javascript with loose equality - \"abstract-date\": can be used for comparing dates in various formats - \"loki\" comparators: slower, safer for mixed datatypes in ranged indexes. This more closely resembles the comparator functionality which existed in LokiJS. - (possible additon) \"string-insensitive\" : could be used for comparing, sorting strings with case insensitivity. Individual comparators can be selected from the above to be used for indexing, sorting, or filtering... whichever makes the most sense from a performance, functional, or type safety perspective. Custom, user-defined comparators If the various 'built-in' comparators don't fit a particular use case, users can define their own comparator functions and add to (or override) comparators within the ComparatorMap. They can then be leveraged in various places for sorting, indexing, filtering. This configuration is done when instancing your Loki database instance, within the constructor. An Example of this might look like the following : // define comparator function let myComparator = (a, b) => { if (a === b) return 0; if (a > b) return 1; return -1; } // pass in any number of comparators to add to or override those aleady registered let db = new Loki(\"test.db\", { comparatorMap: { \"MyComparator\": myComparator } }); Having configured the above example, you might use them within collections, such as this simplesort() operation : // when instancing a new collection, you can specify this to override the default \"js\" unindexedSortComparator. let coll = db.addCollection(\"users\", { unindexedSortComparator: \"MyComparator\" }); coll.insert(someDocuments); // this will use the currently configured default unindexedSortComparator let result = coll.simplesort(\"name\"); // simplesort also allows you to override the default comparator in options let reversed = coll.simplesort(\"name\", { desc: true, unindexedSortComparator: \"string-insensitive\" }); Other uses for utilizing the named comparators include defining your own LokiOperatorPackage and using within RangedIndexes . Those topics will go into details and give code samples within their respective pages. Transform steps such as 'find' filtering and simplesort steps will also be able to leverage these, either explicitly or via options. Summary In the future, anywhere where these comparators can be leveraged, we will likely do so... to allow the ability for the user to customize and optimize LokiDB to best work with their data. Registration of user defined comparators needs to done every time you re-instance the database. Only the names of the comparators are persisted within your saved/serialized database. While this is an additional responsibility, it also allows experimentation to determine the performance (for tuning). Warning : If a user defined comparator is paired with a range index, it is important that the comparator not change over time. Ranged indexes (typically) persist themselves as ordered represenations and future relative calculations of re-organization across inserts, updates, and removes depend on consistent comparison results. If your custom comparator is not used by a ranged index, you are free to experiment and refine the comparison results over time to reflect and refine the functional output of various LokiDB tasks.","title":"Loki Comparators"},{"location":"comparators/#loki-comparators","text":"Comparators (in javascript and loki) are functions which accept two values and return : - 0 : if the first and second are considered equal - -1 : if the first is less than the second - 1 : if the first is greater than the second","title":"Loki Comparators"},{"location":"comparators/#overview","text":"Since comparators now play a important role in customizing and fine-tuning LokiDB, this page will attempt to summarize the reasoning behind this increased structuring. In the previous version of LokiDB (LokiJS), various components such as find ops, BinaryIndices and sorting shared a common set of helper functions serving as a common comparator. This arbitrary co-mingling inadvertently became standard as it would have been too much of a breaking change to decouple that later on (although some attempts to provide additional options were later added). In LokiDB, to support decoupling these various components, we have established a 'ComparatorMap' which is a collection of named comparator functions. LokiDB utilizes these comparators for : - Unindexed sorting - Used with RangedIndexes (such as our provided \"avl\" index) for higher performance filtering. - Can be optionally leveraged within unindexed find() operations (like $eq, $gt, $gte, $lt, $lte, $bewtween) when using our new 'ComparatorOperatorPackage' (See operators.md ).","title":"Overview"},{"location":"comparators/#why-would-i-need-more-than-the-default-js-comparator","text":"Out of the box, LokiDB provides some base comparators : - \"js\" (default) : fastest, pure javascript with strict equality for $eq - \"abstract-js\": fast, pure javascript with loose equality - \"abstract-date\": can be used for comparing dates in various formats - \"loki\" comparators: slower, safer for mixed datatypes in ranged indexes. This more closely resembles the comparator functionality which existed in LokiJS. - (possible additon) \"string-insensitive\" : could be used for comparing, sorting strings with case insensitivity. Individual comparators can be selected from the above to be used for indexing, sorting, or filtering... whichever makes the most sense from a performance, functional, or type safety perspective.","title":"Why would I need more than the default \"js\" comparator?"},{"location":"comparators/#custom-user-defined-comparators","text":"If the various 'built-in' comparators don't fit a particular use case, users can define their own comparator functions and add to (or override) comparators within the ComparatorMap. They can then be leveraged in various places for sorting, indexing, filtering. This configuration is done when instancing your Loki database instance, within the constructor. An Example of this might look like the following : // define comparator function let myComparator = (a, b) => { if (a === b) return 0; if (a > b) return 1; return -1; } // pass in any number of comparators to add to or override those aleady registered let db = new Loki(\"test.db\", { comparatorMap: { \"MyComparator\": myComparator } }); Having configured the above example, you might use them within collections, such as this simplesort() operation : // when instancing a new collection, you can specify this to override the default \"js\" unindexedSortComparator. let coll = db.addCollection(\"users\", { unindexedSortComparator: \"MyComparator\" }); coll.insert(someDocuments); // this will use the currently configured default unindexedSortComparator let result = coll.simplesort(\"name\"); // simplesort also allows you to override the default comparator in options let reversed = coll.simplesort(\"name\", { desc: true, unindexedSortComparator: \"string-insensitive\" }); Other uses for utilizing the named comparators include defining your own LokiOperatorPackage and using within RangedIndexes . Those topics will go into details and give code samples within their respective pages. Transform steps such as 'find' filtering and simplesort steps will also be able to leverage these, either explicitly or via options.","title":"Custom, user-defined comparators"},{"location":"comparators/#summary","text":"In the future, anywhere where these comparators can be leveraged, we will likely do so... to allow the ability for the user to customize and optimize LokiDB to best work with their data. Registration of user defined comparators needs to done every time you re-instance the database. Only the names of the comparators are persisted within your saved/serialized database. While this is an additional responsibility, it also allows experimentation to determine the performance (for tuning). Warning : If a user defined comparator is paired with a range index, it is important that the comparator not change over time. Ranged indexes (typically) persist themselves as ordered represenations and future relative calculations of re-organization across inserts, updates, and removes depend on consistent comparison results. If your custom comparator is not used by a ranged index, you are free to experiment and refine the comparison results over time to reflect and refine the functional output of various LokiDB tasks.","title":"Summary"},{"location":"operator_packages/","text":"LokiOperatorPackages Overview LokiDB allows querying your collections with a \"mongo-like\" query object, passed to a collection.find() or query chain. The set of available \"ops\" which you can include within your query object is called a LokiOperatorPackage . A LokiOperatorPackage represents the unindexed or \"fallback\" implementation of all supported ops. Ranged Indexes allow the highest performance for querying collections... however they only implement a limited subset of ops ($eq, $lt, $lte, $gt, $gte, $between). Filtering other ops (even when a ranged index is applied) falls back to the LokiOperatorPackage registered as that collection's default. In the previous version of LokiDB (LokiJS) there was just one 'LokiOps'. LokiDB allows and provides multiple for you to choose from or even provide your own. Why support multiple implementations of operators? The primary reasons/drivers for our adoption of this approach is the following : Have simplest and fastest minimal javascript implementations of these operators Also have an implementation which is more tolerant of dirty data and mixed datatypes Have an implementation which allows injecting your own comparators. Future-proofing and smoothing transition between major changes (experimental -> default) Attempting to merge/blend any of the above use cases into a single implementation had negative impact on performance, so we created the ability to switch out whole implementations which only needs to be done once per find, rather than switching behavior for every document evaluation within that filtering. Having separate selectable packages also provides future-proofing and development of experimental implementions in parallel with maintaining existing implementations. What are the LokiOperatorPackages which LokiDB supports? Out of the box, LokiDB implements the following operator packages, which you can choose from (currently per-collection) : \"js\" (default) : the default implementation using fastest javascript comparisons. This is an instance of the main LokiOperatorPackage class. \"loki\" : implementation recommended for dirty data / mixed datatypes. This is an instance of LokiAbstractOperator class. comparator - you need to instantiate this yourself and register that with a name within the loki constructor (example below). These are created by instantiating the ComparatorOperatorPackage class, passing in a comparator to its constructor. In practice we have one main implementation of all ops in the (default) \"LokiOperatorPackage\" class which our other implementations extend from and override base behavior where needed. We may provide other implementations later, and you can provide your own implementations. Other variants which we (or you) may provide can simply extend this class and override the ops we/you wish to have different implementations. How would I select an operator package to use for my collection? When you call addCollection, such as : let coll = db.addCollection(\"coll\", { defaultLokiOperatorPackage: \"js\" }); How can I create and register my own operator package? Usually you would extend the default LokiOperatorPackage, however any of our operator package classes can be extended from. An example where we extend and override some of the ops with some arbitrary \"opposite logic\" might be : // extend and override with some opposite logic class MyOperatorPackage extends LokiOperatorPackage { $gt(a, b): boolean { if (a < b) return true; return false; } $lt(a, b): boolean { if (a > b) return true; return false; } } // inject our new operator into global LokiOperatorPackageMap. // if it already exists, it will overwrite... this includes overriding native packages. let db = new Loki(\"test.db\", { lokiOperatorPackageMap : { \"MyOperatorPackage\": new MyOperatorPackage() } }); Having registered that operator package (in the above example), and creating collections which set that to their default operator package (example above that), unindexed find() filters using the $gt and $lt op will exibit your filtering behavior (RangedIndexes have their own optimized implementation of those ops). Any other ops specified in your query objects will use the default implementation in the class which you extended from. How might I create an operator package based on comparators? If you have created your own comparator or wish to use one of ours as the ultimate determination of filtering for $eq, $lt, $lte, $gt, $gte, and $between ops... how might you set up an operator package for that? Here is a quick example showing how you might implement that : // create a custom case-insensitive string comparator let customComparator: ILokiComparer = (a, b) => { if (typeof a === \"string\" && typeof b === \"string\") { a = a.toLocaleLowerCase(); b = b.toLocaleLowerCase(); } if (a === b) return 0; if (a > b) return 1; return -1; }; // instantiate an operator package based on that comparator let myComparatorOperatorPackage = new ComparatorOperatorPackage(customComparator); // inject as named operator package within the Loki constructor let db = new Loki(\"test.db\", { lokiOperatorPackageMap: { \"MyComparatorOperatorPackage\": myComparatorOperatorPackage } });","title":"LokiOperatorPackages"},{"location":"operator_packages/#lokioperatorpackages","text":"","title":"LokiOperatorPackages"},{"location":"operator_packages/#overview","text":"LokiDB allows querying your collections with a \"mongo-like\" query object, passed to a collection.find() or query chain. The set of available \"ops\" which you can include within your query object is called a LokiOperatorPackage . A LokiOperatorPackage represents the unindexed or \"fallback\" implementation of all supported ops. Ranged Indexes allow the highest performance for querying collections... however they only implement a limited subset of ops ($eq, $lt, $lte, $gt, $gte, $between). Filtering other ops (even when a ranged index is applied) falls back to the LokiOperatorPackage registered as that collection's default. In the previous version of LokiDB (LokiJS) there was just one 'LokiOps'. LokiDB allows and provides multiple for you to choose from or even provide your own.","title":"Overview"},{"location":"operator_packages/#why-support-multiple-implementations-of-operators","text":"The primary reasons/drivers for our adoption of this approach is the following : Have simplest and fastest minimal javascript implementations of these operators Also have an implementation which is more tolerant of dirty data and mixed datatypes Have an implementation which allows injecting your own comparators. Future-proofing and smoothing transition between major changes (experimental -> default) Attempting to merge/blend any of the above use cases into a single implementation had negative impact on performance, so we created the ability to switch out whole implementations which only needs to be done once per find, rather than switching behavior for every document evaluation within that filtering. Having separate selectable packages also provides future-proofing and development of experimental implementions in parallel with maintaining existing implementations.","title":"Why support multiple implementations of operators?"},{"location":"operator_packages/#what-are-the-lokioperatorpackages-which-lokidb-supports","text":"Out of the box, LokiDB implements the following operator packages, which you can choose from (currently per-collection) : \"js\" (default) : the default implementation using fastest javascript comparisons. This is an instance of the main LokiOperatorPackage class. \"loki\" : implementation recommended for dirty data / mixed datatypes. This is an instance of LokiAbstractOperator class. comparator - you need to instantiate this yourself and register that with a name within the loki constructor (example below). These are created by instantiating the ComparatorOperatorPackage class, passing in a comparator to its constructor. In practice we have one main implementation of all ops in the (default) \"LokiOperatorPackage\" class which our other implementations extend from and override base behavior where needed. We may provide other implementations later, and you can provide your own implementations. Other variants which we (or you) may provide can simply extend this class and override the ops we/you wish to have different implementations.","title":"What are the LokiOperatorPackages which LokiDB supports?"},{"location":"operator_packages/#how-would-i-select-an-operator-package-to-use-for-my-collection","text":"When you call addCollection, such as : let coll = db.addCollection(\"coll\", { defaultLokiOperatorPackage: \"js\" });","title":"How would I select an operator package to use for my collection?"},{"location":"operator_packages/#how-can-i-create-and-register-my-own-operator-package","text":"Usually you would extend the default LokiOperatorPackage, however any of our operator package classes can be extended from. An example where we extend and override some of the ops with some arbitrary \"opposite logic\" might be : // extend and override with some opposite logic class MyOperatorPackage extends LokiOperatorPackage { $gt(a, b): boolean { if (a < b) return true; return false; } $lt(a, b): boolean { if (a > b) return true; return false; } } // inject our new operator into global LokiOperatorPackageMap. // if it already exists, it will overwrite... this includes overriding native packages. let db = new Loki(\"test.db\", { lokiOperatorPackageMap : { \"MyOperatorPackage\": new MyOperatorPackage() } }); Having registered that operator package (in the above example), and creating collections which set that to their default operator package (example above that), unindexed find() filters using the $gt and $lt op will exibit your filtering behavior (RangedIndexes have their own optimized implementation of those ops). Any other ops specified in your query objects will use the default implementation in the class which you extended from.","title":"How can I create and register my own operator package?"},{"location":"operator_packages/#how-might-i-create-an-operator-package-based-on-comparators","text":"If you have created your own comparator or wish to use one of ours as the ultimate determination of filtering for $eq, $lt, $lte, $gt, $gte, and $between ops... how might you set up an operator package for that? Here is a quick example showing how you might implement that : // create a custom case-insensitive string comparator let customComparator: ILokiComparer = (a, b) => { if (typeof a === \"string\" && typeof b === \"string\") { a = a.toLocaleLowerCase(); b = b.toLocaleLowerCase(); } if (a === b) return 0; if (a > b) return 1; return -1; }; // instantiate an operator package based on that comparator let myComparatorOperatorPackage = new ComparatorOperatorPackage(customComparator); // inject as named operator package within the Loki constructor let db = new Loki(\"test.db\", { lokiOperatorPackageMap: { \"MyComparatorOperatorPackage\": myComparatorOperatorPackage } });","title":"How might I create an operator package based on comparators?"},{"location":"ranged_indexes/","text":"LokiDB Ranged Indexes Overview RangedIndexes in LokiDB represent an interface which higher-performance indexes which can implement so that they can be applied to properties within your LokiDB collections. In LokiDB, we have settled on and implemented an AVL self balancing binary tree (which supports duplicates) as our highest performance index for applying to properties. This AVL index adheres to and implements our IRangedIndex interface. While the \"avl\" ranged index implementation is our only implementation of IRangedIndex, having the interface as an abstraction allows the possibility of offerring alternate implemenations using other algorithms and structures in the future. It also allows users to experiment, create, and inject their own IRangedIndex implementations in a configurable manner. What is the performance of LokiDB's \"avl\" index implementation? The best way to compare our AVL index implementation is to compare this with the former LokiJS's implementation of binary indices. In that comparison, the avl index seems to be roughly 20% faster for finds() but where avl index really shines is in the \"maintenance\" costs and for inserts, updates, and removes. Once you get over a few thousand documents, the logarithmic performance of the avl index for maintenance costs really shines comparared to linear maintenance of the binary indices array-splicing approach. So the AVL index is highly scalable and, as such, it is not very dependent on collection size for the ops which are implemented within it ($eq, $lt, $lte, $gt, $gte, $between and somewhat for $in). On an older Intel Core i5 laptop (in node.js), avl index performance might equate to roughly : - ~800K - 1M find ops/sec doing single object lookups - ~250K ops/sec for inserts, updates, and removes (maintenance) And that approximate performance does not significantly change when we scale from 40K documents to 100K documents. Obviously on newer and higher performance processors this quickly scales up well above those numbers but when compared to LokiJS you would not likely be able to see those number with any collection counts above a couple thousand documents. How can I apply an avl index to a property in my collection? Easy... a simple (javascript) example demonstrating this is the following : const db = new Loki(\"idxtest\"); // create a \"users\" collection, applying an avl index to the \"name\" property of its documents const items = db.addCollection(\"users\", { rangedIndexes: { name: { indexTypeName: \"avl\", comparatorName: \"js\" } } }); What other indexes might I want to have an implementation for in the future? Honestly, most people probably will not need anything other than our AVL index implementation. The AVL tree is known for keeping strict balancing of its property's values as documents are inserted, updated and removed. Other implementations such as the \"Red-Black\" balanced binary search tree algorithms are less strictly balanced so they may have slightly faster inserts, updates, and removes while potentially having slightly slower lookups/finds. If I implement my own RangedIndex, how might I register and use that IRangedIndex implemenation? Typescript example (may provide javascript example in the future) : // define index implementation class customRangedIndex<T> implements IRangedIndex<T> { public name: string; public comparator: ILokiComparer<T>; constructor(name: string, comparator: ILokiComparer<T>) { this.name = name; this.comparator = comparator; } insert(id: number, val: T) { if (!id || !val) throw new Error(\"\"); return; } update(id: number, val: T) { if (!id || val === null) throw new Error(\"\"); return; } remove(id: number) { if (!id) throw new Error(\"\"); return; } restore(tree: any) { if (!tree) throw new Error(\"\"); return; } backup() { return this; } rangeRequest(range?: IRangedIndexRequest<T>) { if (range === null) { // return everything return <number[]> []; } return <number[]> []; } validateIndex() { return true; } } // ranged index implementations need factory function let myCustomIndexFactory = (name: string, cmp: ILokiComparer<any>) => { return new customRangedIndex<any>(name, cmp); }; // register ranged index factory function with loki constructor let db = new Loki(\"test.db\", { rangedIndexFactoryMap: { \"MyCustomRangedIndex\": myCustomIndexFactory } }); // utilize your registered ranged index within a collection let items = db.addCollection<TestUserType>(\"users\", { rangedIndexes: { \"name\": { indexTypeName: \"MyCustomRangedIndex\", comparatorName: \"js\" } } });","title":"LokiDB Ranged Indexes"},{"location":"ranged_indexes/#lokidb-ranged-indexes","text":"","title":"LokiDB Ranged Indexes"},{"location":"ranged_indexes/#overview","text":"RangedIndexes in LokiDB represent an interface which higher-performance indexes which can implement so that they can be applied to properties within your LokiDB collections. In LokiDB, we have settled on and implemented an AVL self balancing binary tree (which supports duplicates) as our highest performance index for applying to properties. This AVL index adheres to and implements our IRangedIndex interface. While the \"avl\" ranged index implementation is our only implementation of IRangedIndex, having the interface as an abstraction allows the possibility of offerring alternate implemenations using other algorithms and structures in the future. It also allows users to experiment, create, and inject their own IRangedIndex implementations in a configurable manner.","title":"Overview"},{"location":"ranged_indexes/#what-is-the-performance-of-lokidbs-avl-index-implementation","text":"The best way to compare our AVL index implementation is to compare this with the former LokiJS's implementation of binary indices. In that comparison, the avl index seems to be roughly 20% faster for finds() but where avl index really shines is in the \"maintenance\" costs and for inserts, updates, and removes. Once you get over a few thousand documents, the logarithmic performance of the avl index for maintenance costs really shines comparared to linear maintenance of the binary indices array-splicing approach. So the AVL index is highly scalable and, as such, it is not very dependent on collection size for the ops which are implemented within it ($eq, $lt, $lte, $gt, $gte, $between and somewhat for $in). On an older Intel Core i5 laptop (in node.js), avl index performance might equate to roughly : - ~800K - 1M find ops/sec doing single object lookups - ~250K ops/sec for inserts, updates, and removes (maintenance) And that approximate performance does not significantly change when we scale from 40K documents to 100K documents. Obviously on newer and higher performance processors this quickly scales up well above those numbers but when compared to LokiJS you would not likely be able to see those number with any collection counts above a couple thousand documents.","title":"What is the performance of LokiDB's \"avl\" index implementation?"},{"location":"ranged_indexes/#how-can-i-apply-an-avl-index-to-a-property-in-my-collection","text":"Easy... a simple (javascript) example demonstrating this is the following : const db = new Loki(\"idxtest\"); // create a \"users\" collection, applying an avl index to the \"name\" property of its documents const items = db.addCollection(\"users\", { rangedIndexes: { name: { indexTypeName: \"avl\", comparatorName: \"js\" } } });","title":"How can I apply an avl index to a property in my collection?"},{"location":"ranged_indexes/#what-other-indexes-might-i-want-to-have-an-implementation-for-in-the-future","text":"Honestly, most people probably will not need anything other than our AVL index implementation. The AVL tree is known for keeping strict balancing of its property's values as documents are inserted, updated and removed. Other implementations such as the \"Red-Black\" balanced binary search tree algorithms are less strictly balanced so they may have slightly faster inserts, updates, and removes while potentially having slightly slower lookups/finds.","title":"What other indexes might I want to have an implementation for in the future?"},{"location":"ranged_indexes/#if-i-implement-my-own-rangedindex-how-might-i-register-and-use-that-irangedindex-implemenation","text":"Typescript example (may provide javascript example in the future) : // define index implementation class customRangedIndex<T> implements IRangedIndex<T> { public name: string; public comparator: ILokiComparer<T>; constructor(name: string, comparator: ILokiComparer<T>) { this.name = name; this.comparator = comparator; } insert(id: number, val: T) { if (!id || !val) throw new Error(\"\"); return; } update(id: number, val: T) { if (!id || val === null) throw new Error(\"\"); return; } remove(id: number) { if (!id) throw new Error(\"\"); return; } restore(tree: any) { if (!tree) throw new Error(\"\"); return; } backup() { return this; } rangeRequest(range?: IRangedIndexRequest<T>) { if (range === null) { // return everything return <number[]> []; } return <number[]> []; } validateIndex() { return true; } } // ranged index implementations need factory function let myCustomIndexFactory = (name: string, cmp: ILokiComparer<any>) => { return new customRangedIndex<any>(name, cmp); }; // register ranged index factory function with loki constructor let db = new Loki(\"test.db\", { rangedIndexFactoryMap: { \"MyCustomRangedIndex\": myCustomIndexFactory } }); // utilize your registered ranged index within a collection let items = db.addCollection<TestUserType>(\"users\", { rangedIndexes: { \"name\": { indexTypeName: \"MyCustomRangedIndex\", comparatorName: \"js\" } } });","title":"If I implement my own RangedIndex, how might I register and use that IRangedIndex implemenation?"}]}