{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 9c7a69c1b909198d82e7","webpack:///./packages/loki/src/event_emitter.js","webpack:///./packages/loki/src/loki.js","webpack:///./packages/loki/src/collection.js","webpack:///./packages/loki/src/resultset.js","webpack:///./packages/loki/src/clone.js","webpack:///./packages/loki/src/utils.js","webpack:///./packages/loki/src/helper.js","webpack:///(webpack)/buildin/global.js","webpack:///./packages/loki/src/unique_index.js","webpack:///./packages/loki/src/exact_index.js","webpack:///./packages/loki/src/dynamic_view.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AC7DA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY,SAAS;AACrB,cAAc,IAAI;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY,SAAS;AACrB,cAAc,IAAI;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;;ACrGyB;AACN;;AAEnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qDAAqD;;AAErD;AACA;AACA,sBAAsB;AACtB,KAAK;AACL;AACA;AACA;;AAEA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;;AAEA,yBAAyB,+FAA+F,KAAK;AAC7H;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,IAAI;AACjB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA,yBAAyB,0FAA0F,KAAK;AACxH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uCAAuC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,KAAK;AAClB;AACA,mBAAmB;AACnB;AACA,kDAAkD,UAAU;AAC5D;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,IAAI,uEAAuE;AACxF,eAAe,WAAW;AAC1B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,WAAW;AAC1B;AACA;AACA;AACA;;AAEA,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA,eAAe,SAAS;AACxB;AACA,6GAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6DAA6D;AAC7D;AACA,eAAe,OAAO;AACtB;AACA,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,MAAM;AACnB,aAAa,KAAK;AAClB,aAAa,MAAM;AACnB,aAAa,QAAQ;AACrB;AACA,eAAe,aAAa;AAC5B;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA,iBAAiB,iCAAiC;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA,iBAAiB,+BAA+B;AAChD;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,kBAAkB;AACxC;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA,+FAA+F;AAC/F;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,uCAAuC;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iGAAiG;AACjG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,KAAK;AAClB,aAAa,QAAQ;AACrB,aAAa,IAAI;AACjB;AACA,eAAe,aAAa;AAC5B;AACA,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,oBAAoB,mBAAmB;AACvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,QAAQ;AACrB,aAAa,MAAM;AACnB,aAAa,KAAK;AAClB,aAAa,MAAM;AACnB,aAAa,QAAQ;AACrB;AACA,eAAe,aAAa;AAC5B;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6EAA6E;AAC7E,6FAA6F;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAqC;AACrC,+FAA+F;;AAE/F;AACA;AACA;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,OAAO;AACpB,aAAa,IAAI;AACjB,aAAa,OAAO;AACpB;AACA,eAAe,MAAM;AACrB;AACA,wDAAwD;AACxD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,iBAAiB,WAAW;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB;AACA,uCAAuC;AACvC;;AAEA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,KAAK;AAClB,aAAa,IAAI;AACjB,eAAe,QAAQ;AACvB;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,KAAK;AAClB,aAAa,IAAI;AACjB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,+EAA+E,4BAA4B;AAC3G;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;;;;;;ACvhCyB;AACL;AACD;AACD;AACE;AACN;AACwB;AACzB;AACU;;AAEvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,gBAAgB;AAC7B,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,IAAI,uEAAuE;AACxF,WAAW,yBAAyB;AACpC;AACA,gCAAgC;AAChC;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB,4BAA4B;AAC5B;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA,qBAAqB,sBAAsB;AAC3C;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,SAAS,cAAc;AACvB,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,yCAAyC;;AAElF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,6BAA6B;AAC9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,gCAAgC;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,qBAAqB,iCAAiC;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,YAAY;AAC1B;AACA;AACA;AACA,qBAAqB,iCAAiC;AACtD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,6BAA6B;AAC1C;AACA,YAAY,gBAAgB;AAC5B,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,eAAe;AAC3B,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,2BAA2B;AAC3B,wBAAwB;;AAExB;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,iCAAiC;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;;AAExB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,wBAAwB;;AAExB;AACA,KAAK;AACL;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,sEAAsE,+BAA+B;AACrG,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,uBAAuB,iCAAiC;AACxD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,QAAQ;AACpB,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,cAAc;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,IAAI;AAChB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;;AAEA,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,cAAc;AAC5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,cAAc,UAAU;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2CAA2C,uBAAuB,cAAc,uBAAuB;AACvG,cAAc;AACd,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,iCAAiC;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,iCAAiC;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,iCAAiC;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY,SAAS;AACrB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,UAAU;AACtB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;;;ACvmEc;AACK;AACY;AACmB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH,qBAAqB,eAAe,oBAAoB;AACxD;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,WAAW,IAAI;AACf,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,8BAA8B,+BAA+B;AAC7D;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,IAAI,mCAAmC;AACpD,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC,wBAAwB,QAAQ;AAChC,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,wBAAwB;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,aAAa,SAAS;AACtB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gBAAgB;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA,uBAAuB,iCAAiC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA;;;AAGA;AACA;AACA;AACA,aAAa,SAAS;AACtB,eAAe,UAAU;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB;AACA,eAAe,MAAM;AACrB;AACA,QAAQ,gFAAgF,KAAK;AAC7F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,WAAW;AAChC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,kBAAkB;AAC/B,aAAa,kBAAkB;AAC/B,aAAa,UAAU,0HAA0H;AACjJ,eAAe,UAAU,uCAAuC,+BAA+B;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,mBAAmB,oBAAoB;AACvC;AACA,wDAAwD;AACxD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AAAA;AAAA;;;;;;;;;AC7oCA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,QAAQ;AAChB;AACA;;AAEA;AACA;;;;;;;;;AClDA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,eAAe,wBAAwB;AACvC;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;AClDA;AAAA;AACA;AACA;AACA;AACA,kBAAkB,IAAI,GAAG,IAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACnSA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;ACpBA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;AC1DA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;ACtCyB;AACP;;AAElB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,mBAAmB,cAAc;AACjC,kCAAkC,8BAA8B,EAAE;AAClE;AACA;AACA;;AAEA,SAAS,gCAAgC;AACzC;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,GAAG,KAAK;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA,iBAAiB,+BAA+B;AAChD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,aAAa,QAAQ;AACrB,eAAe,UAAU;AACzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA,iBAAiB,uBAAuB,KAAK;AAC7C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,aAAa,SAAS;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,eAAe,OAAO,iDAAiD;AACvE;AACA;AACA;AACA,0DAA0D,WAAW;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2CAA2C,WAAW;AACtD;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,qCAAqC;AACrC,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,iBAAiB;AAC9B,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,iBAAiB;AAC9B,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,WAAW;AACnE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AAAA;AAAA","file":"lokijs.loki.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"@lokijs/loki\"] = factory();\n\telse\n\t\troot[\"@lokijs/loki\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9c7a69c1b909198d82e7","/*\n 'listen' is not defined  no-undef\n */\n\n/**\n * LokiEventEmitter is a minimalist version of EventEmitter. It enables any\n * constructor that inherits EventEmitter to emit events and trigger\n * listeners that have been added to the event through the on(event, callback) method\n *\n * @constructor LokiEventEmitter\n */\nexport class LokiEventEmitter {\n\n  constructor() {\n    /**\n\t\t * @prop {hashmap} events - a hashmap, with each property being an array of callbacks\n\t\t */\n    this.events = {};\n\n    /**\n\t\t * @prop {boolean} asyncListeners - boolean determines whether or not the callbacks associated with each event\n\t\t * should happen in an async fashion or not\n\t\t * Default is false, which means events are synchronous\n\t\t */\n    this.asyncListeners = false;\n  }\n\n  /**\n\t * on(eventName, listener) - adds a listener to the queue of callbacks associated to an event\n\t * @param {string|string[]} eventName - the name(s) of the event(s) to listen to\n\t * @param {function} listener - callback function of listener to attach\n\t * @returns {int} the index of the callback in the array of listeners for a particular event\n\t */\n  on(eventName, listener) {\n    let event;\n\n    if (Array.isArray(eventName)) {\n      eventName.forEach((currentEventName) => {\n        this.on(currentEventName, listener);\n      });\n      return listener;\n    }\n\n    event = this.events[eventName];\n    if (!event) {\n      event = this.events[eventName] = [];\n    }\n    event.push(listener);\n    return listener;\n  }\n\n  /**\n\t * emit(eventName, data) - emits a particular event\n\t * with the option of passing optional parameters which are going to be processed by the callback\n\t * provided signatures match (i.e. if passing emit(event, arg0, arg1) the listener should take two parameters)\n\t * @param {string} eventName - the name of the event\n\t * @param {object=} data - optional object passed with the event\n\t */\n  emit(eventName, data) {\n    if (eventName && this.events[eventName]) {\n      this.events[eventName].forEach((listener) => {\n        if (this.asyncListeners) {\n          setTimeout(() => {\n            listener(data);\n          }, 1);\n        } else {\n          listener(data);\n        }\n\n      });\n    }\n  }\n\n  /**\n\t * Alias of LokiEventEmitter.prototype.on\n\t * addListener(eventName, listener) - adds a listener to the queue of callbacks associated to an event\n\t * @param {string|string[]} eventName - the name(s) of the event(s) to listen to\n\t * @param {function} listener - callback function of listener to attach\n\t * @returns {int} the index of the callback in the array of listeners for a particular event\n\t */\n  addListener(eventName, listener) {\n    return this.on(eventName, listener);\n  }\n\n  /**\n\t * removeListener() - removes the listener at position 'index' from the event 'eventName'\n\t * @param {string|string[]} eventName - the name(s) of the event(s) which the listener is attached to\n\t * @param {function} listener - the listener callback function to remove from emitter\n\t */\n  removeListener(eventName, listener) {\n    if (Array.isArray(eventName)) {\n      eventName.forEach((currentEventName) => {\n        this.removeListener(currentEventName, listener);\n      });\n    }\n\n    if (this.events[eventName]) {\n      const listeners = this.events[eventName];\n      listeners.splice(listeners.indexOf(listener), 1);\n    }\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/loki/src/event_emitter.js\n// module id = 0\n// module chunks = 0","import {LokiEventEmitter} from \"./event_emitter\";\nimport {Collection} from \"./collection\";\n\n/*\n 'LokiFsAdapter' is not defined                 no-undef\tx\n 'LokiLocalStorageAdapter' is not defined       no-undef\tx\n 'Collection' is not defined                    no-undef\tx\n 'delim' is not defined                         no-undef\tx\n 'Utils' is not defined                         no-undef\tx\n\n TBD:\n * Default persistence should be not available.\n * getIndexedAdapter is also obsolet\n * Make some functions private.\n * Inflate? -> Utils.copyProperties\n */\n\nfunction getENV() {\n  if (typeof global !== \"undefined\" && (global.android || global.NSObject)) {\n    return \"NATIVESCRIPT\";\n  }\n\n  const isNode = typeof global !== \"undefined\" && ({}).toString.call(global) === \"[object global]\";\n\n  if (isNode) {\n    if (global.window) {\n      return \"NODEJS\"; //node-webkit\n    } else {\n      return \"NODEJS\";\n    }\n  }\n\n  const isBrowser = typeof window !== \"undefined\" && ({}).toString.call(window) === \"[object Window]\";\n  if (typeof document !== \"undefined\") {\n    if (document.URL.indexOf(\"http://\") === -1 && document.URL.indexOf(\"https://\") === -1) {\n      return \"CORDOVA\";\n    }\n    return \"BROWSER\";\n  }\n\n  if (!isBrowser) {\n    throw SyntaxError(\"Unknown enviroment...\");\n  }\n}\n\n/**\n * Loki: The main database class\n * @constructor Loki\n * @extends LokiEventEmitter\n * @param {string} filename - name of the file to be saved to\n * @param {string} env - override environment detection as 'NODEJS', 'BROWSER', 'CORDOVA'\n * @param {string} serializationMethod - ['normal', 'pretty', 'destructured']\n * @param {string} destructureDelimiter - string delimiter used for destructured serialization\n * @param {boolean} verbose - enable console output (default is 'false')\n */\nexport class Loki extends LokiEventEmitter {\n\n  constructor(filename, {serializationMethod = \"normal\", destructureDelimiter = \"$<\\n\", verbose = false, env = getENV()} = {}) {\n    super();\n    this.filename = filename || \"loki.db\";\n    this.collections = [];\n\n    // persist version of code which created the database to the database.\n    // could use for upgrade scenarios\n    this.databaseVersion = 1.5;\n    this.engineVersion = 1.5;\n\n    // autosave support (disabled by default)\n    // pass autosave: true, autosaveInterval: 6000 in options to set 6 second autosave\n    this.autosave = false;\n    this.autosaveInterval = 5000;\n    this.autosaveHandle = null;\n    this._throttledSaves = true;\n\n    this.options = {\n      serializationMethod: serializationMethod,\n      destructureDelimiter: destructureDelimiter\n    };\n\n    // currently keeping persistenceMethod and persistenceAdapter as loki level properties that\n    // will not or cannot be deserialized.  You are required to configure persistence every time\n    // you instantiate a loki object (or use default environment detection) in order to load the database anyways.\n\n    // persistenceMethod could be 'fs', 'localStorage', or 'adapter'\n    // this is optional option param, otherwise environment detection will be used\n    // if user passes their own adapter we will force this method to 'adapter' later, so no need to pass method option.\n    this.persistenceMethod = null;\n\n    // retain reference to optional (non-serializable) persistenceAdapter 'instance'\n    this.persistenceAdapter = null;\n\n    // flags used to throttle saves\n    this._throttledSaveRunning = null;\n    this._throttledSavePending = null;\n\n    // enable console output if verbose flag is set (disabled by default)\n    this.verbose = verbose;\n\n    this.events = {\n      \"init\": [],\n      \"loaded\": [],\n      \"flushChanges\": [],\n      \"close\": [],\n      \"changes\": [],\n      \"warning\": []\n    };\n\n    this.ENV = env;\n\n    this.on(\"init\", this.clearChanges);\n  }\n\n  /**\n   * configures options related to database persistence.\n   *\n   * @param {adapter} adapter - an instance of a loki persistence adapter\n   * @param {boolean} autosave - enables autosave\n   * @param {int} autosaveInterval - time interval (in milliseconds) between saves (if dirty)\n   * @param {boolean} autoload - enables autoload on loki instantiation\n   * @param {object} inflate - options that are passed to loadDatabase if autoload enabled\n   * @param {boolean} throttledSaves - if true, it batches multiple calls to to saveDatabase reducing number of\n   *   disk I/O operations and guaranteeing proper serialization of the calls. Default value is true.\n   * @param {object} persistenceMethod - a persistence method which should be used (fs, local-storage, indexed-db)\n   * @returns {Promise} a Promise that resolves after initialization and (if enabled) autoloading the database\n   */\n  initializePersistence({persistenceMethod, adapter, autosaveInterval, throttledSaves, autosave, inflate, autoload} = {}) {\n    const defaultPersistence = {\n      \"NODEJS\": [\"fs\"],\n      \"BROWSER\": [\"local-storage\", \"indexed-db\"],\n      \"CORDOVA\": [\"local-storage\", \"indexed-db\"],\n      \"MEMORY\": [\"memory\"]\n    };\n\n    const persistenceMethods = {\n      \"fs\": Loki[\"LokiFSStorage\"],\n      \"local-storage\": Loki[\"LokiLocalStorage\"],\n      \"indexed-db\": Loki[\"LokiIndexedStorage\"]\n    };\n\n    this.options.persistenceMethod = persistenceMethod;\n\n    // process the options\n    if (this.options.persistenceMethod !== undefined) {\n      // check if the specified persistence method is known\n      if (typeof(persistenceMethods[this.options.persistenceMethod]) === \"function\") {\n        this.persistenceMethod = this.options.persistenceMethod;\n        this.persistenceAdapter = new persistenceMethods[this.options.persistenceMethod]();\n      }\n      // should be throw an error here, or just fall back to defaults ??\n    }\n\n    this.options.adapter = adapter;\n\n    // if user passes adapter, set persistence mode to adapter and retain persistence adapter instance\n    if (this.options.adapter !== undefined) {\n      this.persistenceMethod = \"adapter\";\n      this.persistenceAdapter = this.options.adapter;\n    }\n\n    // TODO: order?\n    // if by now there is no adapter specified by user nor derived from persistenceMethod: use sensible defaults\n    if (this.persistenceAdapter === null) {\n      let possiblePersistenceMethods = defaultPersistence[this.ENV];\n      if (possiblePersistenceMethods) {\n        for (let i = 0; i < possiblePersistenceMethods.length; i++) {\n          if (possiblePersistenceMethods[persistenceMethods]) {\n            this.persistenceMethod = possiblePersistenceMethods[persistenceMethods];\n            this.persistenceAdapter = new persistenceMethods[this.persistenceMethod]();\n            break;\n          }\n        }\n      }\n    }\n\n    this.options.autosaveInterval = autosaveInterval;\n    this.options.throttledSaves = throttledSaves;\n    if (this.options.throttledSaves !== undefined) {\n      this._throttledSaves = this.options.throttledSaves;\n    }\n    this.options.autosave = autosave;\n\n    this.autosaveDisable();\n\n    let loaded;\n    this.options.autoload = autoload;\n    this.options.inflate = inflate;\n\n    // if they want to load database on loki instantiation, now is a good time to load... after adapter set and before possible autosave initiation\n    if (this.options.autoload) {\n      loaded = this.loadDatabase(this.options.inflate);\n    } else {\n      loaded = Promise.resolve();\n    }\n\n    return loaded.then(() => {\n      if (this.options.autosave) {\n        this.autosaveEnable();\n      }\n    });\n  }\n\n  /**\n   * Copies 'this' database into a new Loki instance. Object references are shared to make lightweight.\n   *\n   * @param {object} options - apply or override collection level settings\n   * @param {bool} options.removeNonSerializable - nulls properties not safe for serialization.\n   */\n  copy(options = {}) {\n    // in case running in an environment without accurate environment detection, pass 'NA'\n    const databaseCopy = new Loki(this.filename, {env: \"NA\"});\n    let clen;\n    let idx;\n\n    // currently inverting and letting loadJSONObject do most of the work\n    databaseCopy.loadJSONObject(this, {\n      retainDirtyFlags: true\n    });\n\n    // since our toJSON is not invoked for reference database adapters, this will let us mimic\n    if (options.removeNonSerializable !== undefined && options.removeNonSerializable === true) {\n      databaseCopy.autosaveHandle = null;\n      databaseCopy.persistenceAdapter = null;\n\n      clen = databaseCopy.collections.length;\n      for (idx = 0; idx < clen; idx++) {\n        databaseCopy.collections[idx].constraints = null;\n        databaseCopy.collections[idx].ttl = null;\n      }\n    }\n\n    return databaseCopy;\n  }\n\n  /**\n   * Adds a collection to the database.\n   * @param {string} name - name of collection to add\n   * @param {object=} options - (optional) options to configure collection with.\n   * @param {string[]} options.unique - array of property names to define unique constraints for\n   * @param {string[]} options.exact - array of property names to define exact constraints for\n   * @param {string[]} options.indices - array property names to define binary indexes for\n   * @param {boolean} options.asyncListeners - default is false\n   * @param {boolean} options.disableChangesApi - default is true\n   * @param {boolean} options.autoupdate - use Object.observe to update objects automatically (default: false)\n   * @param {boolean} options.clone - specify whether inserts and queries clone to/from user\n   * @param {string} options.cloneMethod - 'parse-stringify' (default), 'jquery-extend-deep', 'shallow'\n   * @param {int} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.\n   * @returns {Collection} a reference to the collection which was just added\n   */\n  addCollection(name, options) {\n    const collection = new Collection(name, options);\n    this.collections.push(collection);\n\n    if (this.verbose)\n      collection.console = console;\n\n    return collection;\n  }\n\n  loadCollection(collection) {\n    if (!collection.name) {\n      throw new Error(\"Collection must have a name property to be loaded\");\n    }\n    this.collections.push(collection);\n  }\n\n  /**\n   * Retrieves reference to a collection by name.\n   * @param {string} collectionName - name of collection to look up\n   * @returns {Collection} Reference to collection in database by that name, or null if not found\n   */\n  getCollection(collectionName) {\n    let i;\n    const len = this.collections.length;\n\n    for (i = 0; i < len; i += 1) {\n      if (this.collections[i].name === collectionName) {\n        return this.collections[i];\n      }\n    }\n\n    // no such collection\n    this.emit(\"warning\", \"collection \" + collectionName + \" not found\");\n    return null;\n  }\n\n  listCollections() {\n    let i = this.collections.length;\n    const colls = [];\n\n    while (i--) {\n      colls.push({\n        name: this.collections[i].name,\n        type: this.collections[i].objType,\n        count: this.collections[i].data.length\n      });\n    }\n    return colls;\n  }\n\n  /**\n   * Removes a collection from the database.\n   * @param {string} collectionName - name of collection to remove\n   */\n  removeCollection(collectionName) {\n    let i;\n    const len = this.collections.length;\n\n    for (i = 0; i < len; i += 1) {\n      if (this.collections[i].name === collectionName) {\n        const tmpcol = new Collection(collectionName, {});\n        const curcol = this.collections[i];\n        for (const prop in curcol) {\n          if (curcol[prop] !== undefined && tmpcol[prop] !== undefined) {\n            curcol[prop] = tmpcol[prop];\n          }\n        }\n        this.collections.splice(i, 1);\n        return;\n      }\n    }\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  /**\n   * Serialize database to a string which can be loaded via {@link Loki#loadJSON}\n   *\n   * @returns {string} Stringified representation of the loki database.\n   */\n  serialize(options = {}) {\n    if (options.serializationMethod === undefined) {\n      options.serializationMethod = this.options.serializationMethod;\n    }\n\n    switch (options.serializationMethod) {\n      case \"normal\":\n        return JSON.stringify(this);\n      case \"pretty\":\n        return JSON.stringify(this, null, 2);\n      case \"destructured\":\n        return this.serializeDestructured(); // use default options\n      default:\n        return JSON.stringify(this);\n    }\n  }\n\n  // alias of serialize\n  toJSON() {\n    return {\n      ENV: this.ENV,\n      serializationMethod: this.serializationMethod,\n      autosave: this.autosave,\n      autosaveInterval: this.autosaveInterval,\n      collections: this.collections,\n      databaseVersion: this.databaseVersion,\n      engineVersion: this.engineVersion,\n      filename: this.filename,\n      options: this.options,\n      persistenceAdapter: this.persistenceAdapter,\n      persistenceMethod: this.persistenceMethod,\n      _throttledSaves: this._throttledSaves,\n      verbose: this.verbose,\n    };\n  }\n\n  /**\n   * Destructured JSON serialization routine to allow alternate serialization methods.\n   * Internally, Loki supports destructuring via loki \"serializationMethod' option and\n   * the optional LokiPartitioningAdapter class. It is also available if you wish to do\n   * your own structured persistence or data exchange.\n   *\n   * @param {object=} options - output format options for use externally to loki\n   * @param {bool=} options.partitioned - (default: false) whether db and each collection are separate\n   * @param {int=} options.partition - can be used to only output an individual collection or db (-1)\n   * @param {bool=} options.delimited - (default: true) whether subitems are delimited or subarrays\n   * @param {string=} options.delimiter - override default delimiter\n   *\n   * @returns {string|Array} A custom, restructured aggregation of independent serializations.\n   */\n  serializeDestructured(options = {}) {\n    let idx;\n    let sidx;\n    let result;\n    let resultlen;\n    const reconstruct = [];\n    let dbcopy;\n\n    if (options.partitioned === undefined) {\n      options.partitioned = false;\n    }\n\n    if (options.delimited === undefined) {\n      options.delimited = true;\n    }\n\n    if (options.delimiter === undefined) {\n      options.delimiter = this.options.destructureDelimiter;\n    }\n\n    // 'partitioned' along with 'partition' of 0 or greater is a request for single collection serialization\n    if (options.partitioned === true && options.partition !== undefined && options.partition >= 0) {\n      return this.serializeCollection({\n        delimited: options.delimited,\n        delimiter: options.delimiter,\n        collectionIndex: options.partition\n      });\n    }\n\n    // not just an individual collection, so we will need to serialize db container via shallow copy\n    dbcopy = new Loki(this.filename);\n    dbcopy.loadJSONObject(this);\n\n    for (idx = 0; idx < dbcopy.collections.length; idx++) {\n      dbcopy.collections[idx].data = [];\n    }\n\n    // if we -only- wanted the db container portion, return it now\n    if (options.partitioned === true && options.partition === -1) {\n      // since we are deconstructing, override serializationMethod to normal for here\n      return dbcopy.serialize({\n        serializationMethod: \"normal\"\n      });\n    }\n\n    // at this point we must be deconstructing the entire database\n    // start by pushing db serialization into first array element\n    reconstruct.push(dbcopy.serialize({\n      serializationMethod: \"normal\"\n    }));\n\n    dbcopy = null;\n\n    // push collection data into subsequent elements\n    for (idx = 0; idx < this.collections.length; idx++) {\n      result = this.serializeCollection({\n        delimited: options.delimited,\n        delimiter: options.delimiter,\n        collectionIndex: idx\n      });\n\n      // NDA : Non-Delimited Array : one iterable concatenated array with empty string collection partitions\n      if (options.partitioned === false && options.delimited === false) {\n        if (!Array.isArray(result)) {\n          throw new Error(\"a nondelimited, non partitioned collection serialization did not return an expected array\");\n        }\n\n        // Array.concat would probably duplicate memory overhead for copying strings.\n        // Instead copy each individually, and clear old value after each copy.\n        // Hopefully this will allow g.c. to reduce memory pressure, if needed.\n        resultlen = result.length;\n\n        for (sidx = 0; sidx < resultlen; sidx++) {\n          reconstruct.push(result[sidx]);\n          result[sidx] = null;\n        }\n\n        reconstruct.push(\"\");\n      } else {\n        reconstruct.push(result);\n      }\n    }\n\n    // Reconstruct / present results according to four combinations : D, DA, NDA, NDAA\n    if (options.partitioned) {\n      // DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }\n      // useful for simple future adaptations of existing persistence adapters to save collections separately\n      if (options.delimited) {\n        return reconstruct;\n      }\n      // NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }\n      // This format might be the most versatile for 'rolling your own' partitioned sync or save.\n      // Memory overhead can be reduced by specifying a specific partition, but at this code path they did not, so its all.\n      else {\n        return reconstruct;\n      }\n    } else {\n      // D : one big Delimited string { partitioned: false, delimited : true }\n      // This is the method Loki will use internally if 'destructured'.\n      // Little memory overhead improvements but does not require multiple asynchronous adapter call scheduling\n      if (options.delimited) {\n        // indicate no more collections\n        reconstruct.push(\"\");\n\n        return reconstruct.join(options.delimiter);\n      }\n      // NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }\n      // This format might be best candidate for custom synchronous syncs or saves\n      else {\n        // indicate no more collections\n        reconstruct.push(\"\");\n\n        return reconstruct;\n      }\n    }\n  }\n\n  /**\n   * Utility method to serialize a collection in a 'destructured' format\n   *\n   * @param {object} options - used to determine output of method\n   * @param {int=} options.delimited - whether to return single delimited string or an array\n   * @param {string=} options.delimiter - (optional) if delimited, this is delimiter to use\n   * @param {int} options.collectionIndex -  specify which collection to serialize data for\n   *\n   * @returns {string|array} A custom, restructured aggregation of independent serializations for a single collection.\n   */\n  serializeCollection(options = {}) {\n    let doccount;\n    let docidx;\n    let resultlines = [];\n\n    if (options.delimited === undefined) {\n      options.delimited = true;\n    }\n\n    if (options.collectionIndex === undefined) {\n      throw new Error(\"serializeCollection called without 'collectionIndex' option\");\n    }\n\n    doccount = this.collections[options.collectionIndex].data.length;\n\n    resultlines = [];\n\n    for (docidx = 0; docidx < doccount; docidx++) {\n      resultlines.push(JSON.stringify(this.collections[options.collectionIndex].data[docidx]));\n    }\n\n    // D and DA\n    if (options.delimited) {\n      // indicate no more documents in collection (via empty delimited string)\n      resultlines.push(\"\");\n\n      return resultlines.join(options.delimiter);\n    } else {\n      // NDAA and NDA\n      return resultlines;\n    }\n  }\n\n  /**\n   * Destructured JSON deserialization routine to minimize memory overhead.\n   * Internally, Loki supports destructuring via loki \"serializationMethod' option and\n   * the optional LokiPartitioningAdapter class. It is also available if you wish to do\n   * your own structured persistence or data exchange.\n   *\n   * @param {string|array} destructuredSource - destructured json or array to deserialize from\n   * @param {object=} options - source format options\n   * @param {bool=} options.partitioned - (default: false) whether db and each collection are separate\n   * @param {int=} options.partition - can be used to deserialize only a single partition\n   * @param {bool=} options.delimited - (default: true) whether subitems are delimited or subarrays\n   * @param {string=} options.delimiter - override default delimiter\n   *\n   * @returns {object|array} An object representation of the deserialized database, not yet applied to 'this' db or document array\n   */\n  deserializeDestructured(destructuredSource, options = {}) {\n    let workarray = [];\n    let len;\n    let cdb;\n    let collIndex = 0;\n    let collCount;\n    let lineIndex = 1;\n    let done = false;\n    let currObject;\n\n    if (options.partitioned === undefined) {\n      options.partitioned = false;\n    }\n\n    if (options.delimited === undefined) {\n      options.delimited = true;\n    }\n\n    if (options.delimiter === undefined) {\n      options.delimiter = this.options.destructureDelimiter;\n    }\n\n    // Partitioned\n    // DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }\n    // NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }\n    // -or- single partition\n    if (options.partitioned) {\n      // handle single partition\n      if (options.partition !== undefined) {\n        // db only\n        if (options.partition === -1) {\n          cdb = JSON.parse(destructuredSource[0]);\n\n          return cdb;\n        }\n\n        // single collection, return doc array\n        return this.deserializeCollection(destructuredSource[options.partition + 1], options);\n      }\n\n      // Otherwise we are restoring an entire partitioned db\n      cdb = JSON.parse(destructuredSource[0]);\n      collCount = cdb.collections.length;\n      for (collIndex = 0; collIndex < collCount; collIndex++) {\n        // attach each collection docarray to container collection data, add 1 to collection array index since db is at 0\n        cdb.collections[collIndex].data = this.deserializeCollection(destructuredSource[collIndex + 1], options);\n      }\n\n      return cdb;\n    }\n\n    // Non-Partitioned\n    // D : one big Delimited string { partitioned: false, delimited : true }\n    // NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }\n\n    // D\n    if (options.delimited) {\n      workarray = destructuredSource.split(options.delimiter);\n      destructuredSource = null; // lower memory pressure\n      len = workarray.length;\n\n      if (len === 0) {\n        return null;\n      }\n    }\n    // NDA\n    else {\n      workarray = destructuredSource;\n    }\n\n    // first line is database and collection shells\n    cdb = JSON.parse(workarray[0]);\n    collCount = cdb.collections.length;\n    workarray[0] = null;\n\n    while (!done) {\n      // empty string indicates either end of collection or end of file\n      if (workarray[lineIndex] === \"\") {\n        // if no more collections to load into, we are done\n        if (++collIndex > collCount) {\n          done = true;\n        }\n      } else {\n        currObject = JSON.parse(workarray[lineIndex]);\n        cdb.collections[collIndex].data.push(currObject);\n      }\n\n      // lower memory pressure and advance iterator\n      workarray[lineIndex++] = null;\n    }\n\n    return cdb;\n  }\n\n  /**\n   * Deserializes a destructured collection.\n   *\n   * @param {string|Array} destructuredSource - destructured representation of collection to inflate\n   * @param {object} options - used to describe format of destructuredSource input\n   * @param {int} options.delimited - whether source is delimited string or an array\n   * @param {string} options.delimiter - (optional) if delimited, this is delimiter to use\n   *\n   * @returns {Array} an array of documents to attach to collection.data.\n   */\n  deserializeCollection(destructuredSource, options = {}) {\n    let workarray = [];\n    let idx;\n    let len;\n\n    if (options.partitioned === undefined) {\n      options.partitioned = false;\n    }\n\n    if (options.delimited === undefined) {\n      options.delimited = true;\n    }\n\n    if (options.delimiter === undefined) {\n      options.delimiter = this.options.destructureDelimiter;\n    }\n\n    if (options.delimited) {\n      workarray = destructuredSource.split(options.delimiter);\n      workarray.pop();\n    } else {\n      workarray = destructuredSource;\n    }\n\n    len = workarray.length;\n    for (idx = 0; idx < len; idx++) {\n      workarray[idx] = JSON.parse(workarray[idx]);\n    }\n\n    return workarray;\n  }\n\n  /**\n   * Inflates a loki database from a serialized JSON string\n   *\n   * @param {string} serializedDb - a serialized loki database string\n   * @param {object} options - apply or override collection level settings\n   */\n  loadJSON(serializedDb, options) {\n    let dbObject;\n    if (serializedDb.length === 0) {\n      dbObject = {};\n    } else {\n      // using option defined in instantiated db not what was in serialized db\n      switch (this.options.serializationMethod) {\n        case \"normal\":\n        case \"pretty\":\n          dbObject = JSON.parse(serializedDb);\n          break;\n        case \"destructured\":\n          dbObject = this.deserializeDestructured(serializedDb);\n          break;\n        default:\n          dbObject = JSON.parse(serializedDb);\n          break;\n      }\n    }\n    this.loadJSONObject(dbObject, options);\n  }\n\n  /**\n   * Inflates a loki database from a JS object\n   *\n   * @param {object} dbObject - a serialized loki database string\n   * @param {object} options - apply or override collection level settings\n   * @param {bool?} options.retainDirtyFlags - whether collection dirty flags will be preserved\n   */\n  loadJSONObject(dbObject, options = {}) {\n    const len = dbObject.collections ? dbObject.collections.length : 0;\n\n    this.name = dbObject.name;\n    this.collections = [];\n\n    for (let i = 0; i < len; ++i) {\n      this.collections.push(Collection.fromJSONObject(dbObject.collections[i],\n        options, dbObject.databaseVersion < 1.5));\n    }\n  }\n\n  /**\n   * Emits the close event. In autosave scenarios, if the database is dirty, this will save and disable timer.\n   * Does not actually destroy the db.\n   *\n   * @returns {Promise} a Promise that resolves after closing the database succeeded\n   */\n  close() {\n    let saved;\n    // for autosave scenarios, we will let close perform final save (if dirty)\n    // For web use, you might call from window.onbeforeunload to shutdown database, saving pending changes\n    if (this.autosave) {\n      this.autosaveDisable();\n      // Check if collections are dirty.\n      for (let idx = 0; idx < this.collections.length; idx++) {\n        if (this.collections[idx].dirty) {\n          saved = this.saveDatabase();\n          break;\n        }\n      }\n    }\n\n    return Promise.resolve(saved).then(() => {\n      this.emit(\"close\");\n    });\n  }\n\n  /**-------------------------+\n   | Changes API               |\n   +--------------------------*/\n\n  /**\n   * The Changes API enables the tracking the changes occurred in the collections since the beginning of the session,\n   * so it's possible to create a differential dataset for synchronization purposes (possibly to a remote db)\n   */\n\n  /**\n   * (Changes API) : takes all the changes stored in each\n   * collection and creates a single array for the entire database. If an array of names\n   * of collections is passed then only the included collections will be tracked.\n   *\n   * @param {Array=} optional array of collection names. No arg means all collections are processed.\n   * @returns {Array} array of changes\n   * @see private method createChange() in Collection\n   */\n  generateChangesNotification(arrayOfCollectionNames) {\n    function getCollName(coll) {\n      return coll.name;\n    }\n\n    let changes = [];\n    const selectedCollections = arrayOfCollectionNames || this.collections.map(getCollName);\n\n    this.collections.forEach((coll) => {\n      if (selectedCollections.indexOf(getCollName(coll)) !== -1) {\n        changes = changes.concat(coll.getChanges());\n      }\n    });\n    return changes;\n  }\n\n  /**\n   * (Changes API) - stringify changes for network transmission\n   * @returns {string} string representation of the changes\n   */\n  serializeChanges(collectionNamesArray) {\n    return JSON.stringify(this.generateChangesNotification(collectionNamesArray));\n  }\n\n  /**\n   * (Changes API) : clears all the changes in all collections.\n   */\n  clearChanges() {\n    this.collections.forEach((coll) => {\n      if (coll.flushChanges) {\n        coll.flushChanges();\n      }\n    });\n  }\n\n  /**\n   * Wait for throttledSaves to complete and invoke your callback when drained or duration is met.\n   *\n   * @param {object=} options - configuration options\n   * @param {boolean} options.recursiveWait - (default: true) if after queue is drained, another save was kicked off, wait for it\n   * @param {bool} options.recursiveWaitLimit - (default: false) limit our recursive waiting to a duration\n   * @param {int} options.recursiveWaitLimitDelay - (default: 2000) cutoff in ms to stop recursively re-draining\n   * @returns {Promise} a Promise that resolves when save queue is drained, it is passed a sucess parameter value\n   */\n  throttledSaveDrain(options = {}) {\n    const now = (new Date()).getTime();\n\n    if (!this._throttledSaves) {\n      return Promise.resolve();\n    }\n\n    if (options.recursiveWait === undefined) {\n      options.recursiveWait = true;\n    }\n    if (options.recursiveWaitLimit === undefined) {\n      options.recursiveWaitLimit = false;\n    }\n    if (options.recursiveWaitLimitDuration === undefined) {\n      options.recursiveWaitLimitDuration = 2000;\n    }\n    if (options.started === undefined) {\n      options.started = (new Date()).getTime();\n    }\n\n    // if save is pending\n    if (this._throttledSaves && this._throttledSaveRunning !== null) {\n      // if we want to wait until we are in a state where there are no pending saves at all\n      if (options.recursiveWait) {\n        // queue the following meta callback for when it completes\n        return Promise.resolve(Promise.all([this._throttledSaveRunning, this._throttledSavePending])).then(() => {\n          if (this._throttledSaveRunning !== null || this._throttledSavePending !== null) {\n            if (options.recursiveWaitLimit && (now - options.started > options.recursiveWaitLimitDuration)) {\n              return Promise.reject();\n            }\n            return this.throttledSaveDrain(options);\n          } else {\n            return Promise.resolve();\n          }\n        });\n      }\n      // just notify when current queue is depleted\n      else {\n        return Promise.resolve(this._throttledSaveRunning);\n      }\n    }\n    // no save pending, just callback\n    else {\n      return Promise.resolve();\n    }\n  }\n\n  /**\n   * Internal load logic, decoupled from throttling/contention logic\n   *\n   * @param {object} options - an object containing inflation options for each collection\n   * @returns {Promise} a Promise that resolves after the database is loaded\n   */\n  _loadDatabase(options = {}) {\n    // the persistenceAdapter should be present if all is ok, but check to be sure.\n    if (this.persistenceAdapter === null) {\n      return Promise.reject(new Error(\"persistenceAdapter not configured\"));\n    }\n\n    return Promise.resolve(this.persistenceAdapter.loadDatabase(this.filename))\n      .then((dbString) => {\n        if (typeof (dbString) === \"string\") {\n          this.loadJSON(dbString, options);\n          this.emit(\"load\", this);\n        } else {\n          // if adapter has returned an js object (other than null or error) attempt to load from JSON object\n          if (typeof (dbString) === \"object\" && dbString !== null && !(dbString instanceof Error)) {\n            this.loadJSONObject(dbString, options);\n            this.emit(\"load\", this);\n          } else {\n            if (dbString instanceof Error)\n              throw dbString;\n\n            throw new TypeError(\"The persistence adapter did not load a serialized DB string or object.\");\n          }\n        }\n      });\n  }\n\n  /**\n   * Handles loading from file system, local storage, or adapter (indexeddb)\n   *    This method utilizes loki configuration options (if provided) to determine which\n   *    persistence method to use, or environment detection (if configuration was not provided).\n   *    To avoid contention with any throttledSaves, we will drain the save queue first.\n   *\n   * @param {object} options - if throttling saves and loads, this controls how we drain save queue before loading\n   * @param {boolean} options.recursiveWait - (default: true) wait recursively until no saves are queued\n   * @param {bool} options.recursiveWaitLimit - (default: false) limit our recursive waiting to a duration\n   * @param {int} options.recursiveWaitLimitDelay - (default: 2000) cutoff in ms to stop recursively re-draining\n   * @returns {Promise} a Promise that resolves after the database is loaded\n   */\n  loadDatabase(options) {\n    // if throttling disabled, just call internal\n    if (!this._throttledSaves) {\n      return this._loadDatabase(options);\n    }\n\n    // try to drain any pending saves in the queue to lock it for loading\n    return this.throttledSaveDrain(options).then(() => {\n      // pause/throttle saving until loading is done\n      this._throttledSaveRunning = this._loadDatabase(options).then(() => {\n        // now that we are finished loading, if no saves were throttled, disable flag\n        this._throttledSaveRunning = null;\n      });\n      return this._throttledSaveRunning;\n    }, () => {\n      throw new Error(\"Unable to pause save throttling long enough to read database\");\n    });\n  }\n\n  _saveDatabase() {\n    // the persistenceAdapter should be present if all is ok, but check to be sure.\n    if (this.persistenceAdapter === null) {\n      return Promise.reject(new Error(\"persistenceAdapter not configured\"));\n    }\n\n    let saved;\n\n    // check if the adapter is requesting (and supports) a 'reference' mode export\n    if (this.persistenceAdapter.mode === \"reference\" && typeof this.persistenceAdapter.exportDatabase === \"function\") {\n      // filename may seem redundant but loadDatabase will need to expect this same filename\n      saved = this.persistenceAdapter.exportDatabase(this.filename, this.copy({removeNonSerializable: true}));\n    }\n    // otherwise just pass the serialized database to adapter\n    else {\n      saved = this.persistenceAdapter.saveDatabase(this.filename, this.serialize());\n    }\n\n    return Promise.resolve(saved).then(() => {\n      // Set all collection not dirty.\n      for (let idx = 0; idx < this.collections.length; idx++) {\n        this.collections[idx].dirty = false;\n      }\n      this.emit(\"save\");\n    });\n  }\n\n  /**\n   * Handles saving to file system, local storage, or adapter (indexeddb)\n   *    This method utilizes loki configuration options (if provided) to determine which\n   *    persistence method to use, or environment detection (if configuration was not provided).\n   *\n   * @returns {Promise} a Promise that resolves after the database is persisted\n   */\n  saveDatabase() {\n    if (!this._throttledSaves) {\n      return this._saveDatabase();\n    }\n\n    // if the db save is currently running, a new promise for a next db save is created\n    // all calls to save db will get this new promise which will be processed right after\n    // the current db save is finished\n    if (this._throttledSaveRunning !== null && this._throttledSavePending === null) {\n      this._throttledSavePending = Promise.resolve(this._throttledSaveRunning).then(() => {\n        this._throttledSaveRunning = null;\n        this._throttledSavePending = null;\n        return this.saveDatabase();\n      });\n    }\n    if (this._throttledSavePending !== null) {\n      return this._throttledSavePending;\n    }\n    this._throttledSaveRunning = this._saveDatabase().then(() => {\n      this._throttledSaveRunning = null;\n    });\n\n    return this._throttledSaveRunning;\n  }\n\n  /**\n   * Handles deleting a database from file system, local storage, or adapter (indexeddb)\n   *\n   * @returns {Promise} a Promise that resolves after the database is deleted\n   */\n  deleteDatabase() {\n    // the persistenceAdapter should be present if all is ok, but check to be sure.\n    if (this.persistenceAdapter === null) {\n      return Promise.reject(new Error(\"persistenceAdapter not configured\"));\n    }\n\n    return Promise.resolve(this.persistenceAdapter.deleteDatabase(this.filename));\n  }\n\n  /**\n   * autosaveEnable - begin a javascript interval to periodically save the database.\n   *\n   */\n  autosaveEnable() {\n    if (this.autosaveHandle) {\n      return;\n    }\n\n    let running = true;\n\n    this.autosave = true;\n    this.autosaveHandle = () => {\n      running = false;\n      this.autosaveHandle = undefined;\n    };\n\n    setTimeout(() => {\n      if (running) {\n        this.saveDatabase().then(this.saveDatabase, this.saveDatabase);\n      }\n    }, this.autosaveInterval);\n  }\n\n  /**\n   * autosaveDisable - stop the autosave interval timer.\n   *\n   */\n  autosaveDisable() {\n    this.autosave = false;\n\n    if (this.autosaveHandle) {\n      this.autosaveHandle();\n    }\n  }\n}\n\nexport default Loki;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/loki/src/loki.js\n// module id = 1\n// module chunks = 0","import {LokiEventEmitter} from \"./event_emitter\";\nimport {UniqueIndex} from \"./unique_index\";\nimport {ExactIndex} from \"./exact_index\";\nimport {Resultset} from \"./resultset\";\nimport {DynamicView} from \"./dynamic_view\";\nimport {clone} from \"./clone\";\nimport {ltHelper, gtHelper, aeqHelper} from \"./helper\";\nimport {Loki} from \"./loki\";\nimport {copyProperties} from \"./utils\";\n\n/*\n 'isDeepProperty' is not defined              no-undef\n 'deepProperty' is not defined                no-undef\n 'average' is not defined                     no-undef\n 'standardDeviation' is not defined           no-undef\n 'sub' is not defined                         no-undef\n\n byExample?\n indexing -> own class?\n remove data only?\n */\n\n/**\n * General utils, including statistical functions\n */\nfunction isDeepProperty(field) {\n  return field.indexOf(\".\") !== -1;\n}\n\nfunction parseBase10(num) {\n  return parseFloat(num, 10);\n}\n\nfunction add(a, b) {\n  return a + b;\n}\n\nfunction sub(a, b) {\n  return a - b;\n}\n\nfunction average(array) {\n  return (array.reduce(add, 0)) / array.length;\n}\n\nfunction standardDeviation(values) {\n  const avg = average(values);\n  const squareDiffs = values.map((value) => {\n    const diff = value - avg;\n    const sqrDiff = diff * diff;\n    return sqrDiff;\n  });\n\n  const avgSquareDiff = average(squareDiffs);\n\n  const stdDev = Math.sqrt(avgSquareDiff);\n  return stdDev;\n}\n\nfunction deepProperty(obj, property, isDeep) {\n  if (isDeep === false) {\n    // pass without processing\n    return obj[property];\n  }\n  const pieces = property.split(\".\");\n  let root = obj;\n  while (pieces.length > 0) {\n    root = root[pieces.shift()];\n  }\n  return root;\n}\n\n/**\n * Collection class that handles documents of same type\n * @extends LokiEventEmitter\n */\nexport class Collection extends LokiEventEmitter {\n\n  /**\n   * @param {string} name - collection name\n   * @param {(array|object)=} options - (optional) array of property names to be indicized OR a configuration object\n   * @param {array} options.unique - array of property names to define unique constraints for\n   * @param {array} options.exact - array of property names to define exact constraints for\n   * @param {array} options.indices - array property names to define binary indexes for\n   * @param {boolean} options.adaptiveBinaryIndices - collection indices will be actively rebuilt rather than lazily (default: true)\n   * @param {boolean} options.asyncListeners - default is false\n   * @param {boolean} options.disableChangesApi - default is true\n   * @param {boolean} options.autoupdate - use Object.observe to update objects automatically (default: false)\n   * @param {boolean} options.clone - specify whether inserts and queries clone to/from user\n   * @param {boolean} options.serializableIndices  - ensures indexed property values are serializable (default: true)\n   * @param {string} options.cloneMethod - 'parse-stringify' (default), 'jquery-extend-deep', 'shallow'\n   * @param {int} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.\n   * @see {@link Loki#addCollection} for normal creation of collections\n   */\n  constructor(name, options = {}) {\n    super();\n    // the name of the collection\n\n    this.name = name;\n    // the data held by the collection\n    this.data = [];\n    this.idIndex = []; // index of id\n    this.binaryIndices = {}; // user defined indexes\n    this.constraints = {\n      unique: {},\n      exact: {}\n    };\n\n    // unique contraints contain duplicate object references, so they are not persisted.\n    // we will keep track of properties which have unique contraint applied here, and regenerate on load\n    this.uniqueNames = [];\n\n    // transforms will be used to store frequently used query chains as a series of steps\n    // which itself can be stored along with the database.\n    this.transforms = {};\n\n    // the object type of the collection\n    this.objType = name;\n\n    // in autosave scenarios we will use collection level dirty flags to determine whether save is needed.\n    // currently, if any collection is dirty we will autosave the whole database if autosave is configured.\n    // defaulting to true since this is called from addCollection and adding a collection should trigger save\n    this.dirty = true;\n\n    // private holders for cached data\n    this.cachedIndex = null;\n    this.cachedBinaryIndex = null;\n    this.cachedData = null;\n\n    /* OPTIONS */\n    // exact match and unique constraints\n    if (options.unique !== undefined) {\n      if (!Array.isArray(options.unique)) {\n        options.unique = [options.unique];\n      }\n      options.unique.forEach((prop) => {\n        this.uniqueNames.push(prop); // used to regenerate on subsequent database loads\n        this.constraints.unique[prop] = new UniqueIndex(prop);\n      });\n    }\n\n    if (options.exact !== undefined) {\n      options.exact.forEach((prop) => {\n        this.constraints.exact[prop] = new ExactIndex(prop);\n      });\n    }\n\n    // Inverted index\n    this._fullTextSearch = null;\n    if (Loki.FullTextSearch !== undefined) {\n      this._fullTextSearch = options.fullTextSearch !== undefined\n        ? new (Loki.FullTextSearch.FullTextSearch)(options.fullTextSearch) : null;\n    }\n\n    // if set to true we will optimally keep indices 'fresh' during insert/update/remove ops (never dirty/never needs rebuild)\n    // if you frequently intersperse insert/update/remove ops between find ops this will likely be significantly faster option.\n    this.adaptiveBinaryIndices = options.adaptiveBinaryIndices !== undefined ? options.adaptiveBinaryIndices : true;\n\n    // is collection transactional\n    this.transactional = options.transactional !== undefined ? options.transactional : false;\n\n    // options to clone objects when inserting them\n    this.cloneObjects = options.clone !== undefined ? options.clone : false;\n\n    // default clone method (if enabled) is parse-stringify\n    this.cloneMethod = options.cloneMethod !== undefined ? options.cloneMethod : \"parse-stringify\";\n\n    // option to make event listeners async, default is sync\n    this.asyncListeners = options.asyncListeners !== undefined ? options.asyncListeners : false;\n\n    // disable track changes\n    this.disableChangesApi = options.disableChangesApi !== undefined ? options.disableChangesApi : true;\n\n    // option to observe objects and update them automatically, ignored if Object.observe is not supported\n    this.autoupdate = options.autoupdate !== undefined ? options.autoupdate : false;\n\n    // by default, if you insert a document into a collection with binary indices, if those indexed properties contain\n    // a DateTime we will convert to epoch time format so that (across serializations) its value position will be the\n    // same 'after' serialization as it was 'before'.\n    this.serializableIndices = options.serializableIndices !== undefined ? options.serializableIndices : true;\n\n    //option to activate a cleaner daemon - clears \"aged\" documents at set intervals.\n    this.ttl = {\n      age: null,\n      ttlInterval: null,\n      daemon: null\n    };\n    this.setTTL(options.ttl || -1, options.ttlInterval);\n\n    // currentMaxId - change manually at your own peril!\n    this.maxId = 0;\n\n    this._dynamicViews = [];\n\n    // events\n    this.events = {\n      \"insert\": [],\n      \"update\": [],\n      \"pre-insert\": [],\n      \"pre-update\": [],\n      \"close\": [],\n      \"flushbuffer\": [],\n      \"error\": [],\n      \"delete\": [],\n      \"warning\": []\n    };\n\n    // changes are tracked by collection and aggregated by the db\n    this.changes = [];\n\n    // initialize the id index\n    this.ensureId();\n    let indices = [];\n    // initialize optional user-supplied indices array ['age', 'lname', 'zip']\n    if (options && options.indices) {\n      if (Object.prototype.toString.call(options.indices) === \"[object Array]\") {\n        indices = options.indices;\n      } else if (typeof options.indices === \"string\") {\n        indices = [options.indices];\n      } else {\n        throw new TypeError(\"Indices needs to be a string or an array of strings\");\n      }\n    }\n\n    for (let idx = 0; idx < indices.length; idx++) {\n      this.ensureIndex(indices[idx]);\n    }\n\n    function observerCallback(changes) {\n\n      const changedObjects = typeof Set === \"function\" ? new Set() : [];\n\n      if (!changedObjects.add)\n        changedObjects.add = function (object) {\n          if (this.indexOf(object) === -1)\n            this.push(object);\n          return this;\n        };\n\n      changes.forEach((change) => {\n        changedObjects.add(change.object);\n      });\n\n      changedObjects.forEach((object) => {\n        if (object.$loki === undefined)\n          return this.removeAutoUpdateObserver(object);\n        try {\n          this.update(object);\n        } catch (err) {/**/}\n      });\n    }\n\n    this.observerCallback = observerCallback;\n\n    const self = this;\n    /*\n\t\t * This method creates a clone of the current status of an object and associates operation and collection name,\n\t\t * so the parent db can aggregate and generate a changes object for the entire db\n\t\t */\n    function createChange(name, op, obj) {\n      self.changes.push({\n        name,\n        operation: op,\n        obj: JSON.parse(JSON.stringify(obj))\n      });\n    }\n\n    // clear all the changes\n    function flushChanges() {\n      self.changes = [];\n    }\n\n    this.getChanges = () => this.changes;\n\n    this.flushChanges = flushChanges;\n\n    /**\n\t\t * If the changes API is disabled make sure only metadata is added without re-evaluating everytime if the changesApi is enabled\n\t\t */\n    function insertMeta(obj) {\n      let len;\n      let idx;\n\n      if (!obj) {\n        return;\n      }\n\n      // if batch insert\n      if (Array.isArray(obj)) {\n        len = obj.length;\n\n        for (idx = 0; idx < len; idx++) {\n          if (obj[idx].meta === undefined) {\n            obj[idx].meta = {};\n          }\n\n          obj[idx].meta.created = (new Date()).getTime();\n          obj[idx].meta.revision = 0;\n        }\n\n        return;\n      }\n\n      // single object\n      if (!obj.meta) {\n        obj.meta = {};\n      }\n\n      obj.meta.created = (new Date()).getTime();\n      obj.meta.revision = 0;\n    }\n\n    function updateMeta(obj) {\n      if (!obj) {\n        return;\n      }\n      obj.meta.updated = (new Date()).getTime();\n      obj.meta.revision += 1;\n    }\n\n    function createInsertChange(obj) {\n      createChange(self.name, \"I\", obj);\n    }\n\n    function createUpdateChange(obj) {\n      createChange(self.name, \"U\", obj);\n    }\n\n    function insertMetaWithChange(obj) {\n      insertMeta(obj);\n      createInsertChange(obj);\n    }\n\n    function updateMetaWithChange(obj) {\n      updateMeta(obj);\n      createUpdateChange(obj);\n    }\n\n\n    /* assign correct handler based on ChangesAPI flag */\n    let insertHandler;\n\n    let updateHandler;\n\n    function setHandlers() {\n      insertHandler = self.disableChangesApi ? insertMeta : insertMetaWithChange;\n      updateHandler = self.disableChangesApi ? updateMeta : updateMetaWithChange;\n    }\n\n    setHandlers();\n\n    this.setChangesApi = (enabled) => {\n      this.disableChangesApi = !enabled;\n      setHandlers();\n    };\n    /**\n\t\t * built-in events\n\t\t */\n    this.on(\"insert\", (obj) => {\n      insertHandler(obj);\n    });\n\n    this.on(\"update\", (obj) => {\n      updateHandler(obj);\n    });\n\n    this.on(\"delete\", (obj) => {\n      if (!this.disableChangesApi) {\n        createChange(this.name, \"R\", obj);\n      }\n    });\n\n    this.on(\"warning\", (warning) => {\n      this.console.warn(warning);\n    });\n    // for de-serialization purposes\n    flushChanges();\n\n    this.console = {\n      log() {\n      },\n      warn() {\n      },\n      error() {\n      },\n    };\n\n    /* ------ STAGING API -------- */\n    /**\n\t\t * stages: a map of uniquely identified 'stages', which hold copies of objects to be\n\t\t * manipulated without affecting the data in the original collection\n\t\t */\n    this.stages = {};\n    this.commitLog = [];\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      _dynamicViews: this._dynamicViews,\n      uniqueNames: this.uniqueNames,\n      transforms: this.transforms,\n      binaryIndices: this.binaryIndices,\n      data: this.data,\n      idIndex: this.idIndex,\n      maxId: this.maxId,\n      dirty: this.dirty,\n      adaptiveBinaryIndices: this.adaptiveBinaryIndices,\n      transactional: this.transactional,\n      asyncListeners: this.asyncListeners,\n      disableChangesApi: this.disableChangesApi,\n      cloneObjects: this.cloneObjects,\n      cloneMethod: this.cloneMethod,\n      autoupdate: this.autoupdate,\n      changes: this.changes,\n    };\n  }\n\n  static fromJSONObject(obj, options, forceRebuild) {\n    let coll = new Collection(obj.name, {disableChangesApi: obj.disableChangesApi});\n\n    coll.adaptiveBinaryIndices = obj.adaptiveBinaryIndices !== undefined ? (obj.adaptiveBinaryIndices === true) : false;\n    coll.transactional = obj.transactional;\n    coll.asyncListeners = obj.asyncListeners;\n    coll.disableChangesApi = obj.disableChangesApi;\n    coll.cloneObjects = obj.cloneObjects;\n    coll.cloneMethod = obj.cloneMethod || \"parse-stringify\";\n    coll.autoupdate = obj.autoupdate;\n    coll.changes = obj.changes;\n\n    coll.dirty = (options.retainDirtyFlags === true) ? obj.dirty : false;\n\n    function makeLoader(coll) {\n      const collOptions = options[coll.name];\n      let inflater;\n\n      if (collOptions.proto) {\n        inflater = collOptions.inflate || copyProperties;\n\n        return (data) => {\n          const collObj = new (collOptions.proto)();\n          inflater(data, collObj);\n          return collObj;\n        };\n      }\n\n      return collOptions.inflate;\n    }\n\n    // load each element individually\n    let clen = obj.data.length;\n    let j = 0;\n    if (options && options[obj.name] !== undefined) {\n      let loader = makeLoader(obj);\n\n      for (j; j < clen; j++) {\n        let collObj = loader(obj.data[j]);\n        coll.data[j] = collObj;\n        coll.addAutoUpdateObserver(coll);\n      }\n    } else {\n\n      for (j; j < clen; j++) {\n        coll.data[j] = obj.data[j];\n        coll.addAutoUpdateObserver(coll.data[j]);\n      }\n    }\n\n    coll.maxId = (typeof obj.maxId === \"undefined\") ? 0 : obj.maxId;\n    coll.idIndex = obj.idIndex;\n    if (obj.binaryIndices !== undefined) {\n      coll.binaryIndices = obj.binaryIndices;\n    }\n    if (obj.transforms !== undefined) {\n      coll.transforms = obj.transforms;\n    }\n\n    coll.ensureId();\n\n    // regenerate unique indexes\n    coll.uniqueNames = [];\n    if (obj.uniqueNames !== undefined) {\n      coll.uniqueNames = obj.uniqueNames;\n      for (j = 0; j < coll.uniqueNames.length; j++) {\n        coll.ensureUniqueIndex(coll.uniqueNames[j]);\n      }\n    }\n\n    // in case they are loading a database created before we added dynamic views, handle undefined\n    if (obj._dynamicViews === undefined)\n      return coll;\n\n    // reinflate DynamicViews and attached Resultsets\n    for (let idx = 0; idx < obj._dynamicViews.length; idx++) {\n      coll._dynamicViews.push(DynamicView.fromJSONObject(coll, obj._dynamicViews[idx]));\n    }\n\n    // Upgrade Logic for binary index refactoring at version 1.5\n    if (forceRebuild) {\n      // rebuild all indices\n      coll.ensureAllIndexes(true);\n      coll.dirty = true;\n    }\n\n    return coll;\n  }\n\n  addAutoUpdateObserver(object) {\n    if (!this.autoupdate || typeof Object.observe !== \"function\")\n      return;\n\n    Object.observe(object, this.observerCallback, [\"add\", \"update\", \"delete\", \"reconfigure\", \"setPrototype\"]);\n  }\n\n  removeAutoUpdateObserver(object) {\n    if (!this.autoupdate || typeof Object.observe !== \"function\")\n      return;\n\n    Object.unobserve(object, this.observerCallback);\n  }\n\n  /**\n\t * Adds a named collection transform to the collection\n\t * @param {string} name - name to associate with transform\n\t * @param {array} transform - an array of transformation 'step' objects to save into the collection\n\t * @memberof Collection\n\t */\n  addTransform(name, transform) {\n    if (this.transforms[name] !== undefined) {\n      throw new Error(\"a transform by that name already exists\");\n    }\n\n    this.transforms[name] = transform;\n  }\n\n  /**\n\t * Updates a named collection transform to the collection\n\t * @param {string} name - name to associate with transform\n\t * @param {object} transform - a transformation object to save into collection\n\t * @memberof Collection\n\t */\n  setTransform(name, transform) {\n    this.transforms[name] = transform;\n  }\n\n  /**\n\t * Removes a named collection transform from the collection\n\t * @param {string} name - name of collection transform to remove\n\t * @memberof Collection\n\t */\n  removeTransform(name) {\n    delete this.transforms[name];\n  }\n\n  byExample(template) {\n    let k;\n    let obj;\n    let query;\n    query = [];\n    for (k in template) {\n      if (template[k] === undefined) continue;\n      query.push((\n        obj = {},\n        obj[k] = template[k],\n        obj\n      ));\n    }\n    return {\n      \"$and\": query\n    };\n  }\n\n  findObject(template) {\n    return this.findOne(this.byExample(template));\n  }\n\n  findObjects(template) {\n    return this.find(this.byExample(template));\n  }\n\n  /*----------------------------+\n\t | TTL daemon                  |\n\t +----------------------------*/\n  ttlDaemonFuncGen() {\n    const collection = this;\n    const age = this.ttl.age;\n    return function ttlDaemon() {\n      const now = Date.now();\n      const toRemove = collection.chain().where(function daemonFilter(member) {\n        const timestamp = member.meta.updated || member.meta.created;\n        const diff = now - timestamp;\n        return age < diff;\n      });\n      toRemove.remove();\n    };\n  }\n\n  setTTL(age, interval) {\n    if (age < 0) {\n      clearInterval(this.ttl.daemon);\n    } else {\n      this.ttl.age = age;\n      this.ttl.ttlInterval = interval;\n      this.ttl.daemon = setInterval(this.ttlDaemonFuncGen(), interval);\n    }\n  }\n\n  /*----------------------------+\n\t | INDEXING                    |\n\t +----------------------------*/\n\n  /**\n\t * create a row filter that covers all documents in the collection\n\t */\n  prepareFullDocIndex() {\n    const len = this.data.length;\n    const indexes = new Array(len);\n    for (let i = 0; i < len; i += 1) {\n      indexes[i] = i;\n    }\n    return indexes;\n  }\n\n  /**\n\t * Will allow reconfiguring certain collection options.\n\t * @param {boolean} options.adaptiveBinaryIndices - collection indices will be actively rebuilt rather than lazily\n\t * @memberof Collection\n\t */\n  configureOptions(options) {\n    options = options || {};\n\n    if (options.adaptiveBinaryIndices !== undefined) {\n      this.adaptiveBinaryIndices = options.adaptiveBinaryIndices;\n\n      // if switching to adaptive binary indices, make sure none are 'dirty'\n      if (this.adaptiveBinaryIndices) {\n        this.ensureAllIndexes();\n      }\n    }\n  }\n\n  /**\n\t * Ensure binary index on a certain field\n\t * @param {string} property - name of property to create binary index on\n\t * @param {boolean=} force - (Optional) flag indicating whether to construct index immediately\n\t * @memberof Collection\n\t */\n  ensureIndex(property, force) {\n    // optional parameter to force rebuild whether flagged as dirty or not\n    if (typeof(force) === \"undefined\") {\n      force = false;\n    }\n\n    if (property === null || property === undefined) {\n      throw new Error(\"Attempting to set index without an associated property\");\n    }\n\n    if (this.binaryIndices[property] && !force) {\n      if (!this.binaryIndices[property].dirty) return;\n    }\n\n    // if the index is already defined and we are using adaptiveBinaryIndices and we are not forcing a rebuild, return.\n    if (this.adaptiveBinaryIndices === true && this.binaryIndices[property] !== undefined && !force) {\n      return;\n    }\n\n    const index = {\n      \"name\": property,\n      \"dirty\": true,\n      \"values\": this.prepareFullDocIndex()\n    };\n    this.binaryIndices[property] = index;\n\n    const wrappedComparer =\n   (((p, data) => (a, b) => {\n     const objAp = data[a][p];\n     const objBp = data[b][p];\n     if (objAp !== objBp) {\n       if (ltHelper(objAp, objBp, false)) return -1;\n       if (gtHelper(objAp, objBp, false)) return 1;\n     }\n     return 0;\n   }))(property, this.data);\n\n    index.values.sort(wrappedComparer);\n    index.dirty = false;\n\n    this.dirty = true; // for autosave scenarios\n  }\n\n  getSequencedIndexValues(property) {\n    let idx;\n    const idxvals = this.binaryIndices[property].values;\n    let result = \"\";\n\n    for (idx = 0; idx < idxvals.length; idx++) {\n      result += \" [\" + idx + \"] \" + this.data[idxvals[idx]][property];\n    }\n\n    return result;\n  }\n\n  ensureUniqueIndex(field) {\n    let index = this.constraints.unique[field];\n    if (!index) {\n      // keep track of new unique index for regenerate after database (re)load.\n      if (this.uniqueNames.indexOf(field) == -1) {\n        this.uniqueNames.push(field);\n      }\n    }\n\n    // if index already existed, (re)loading it will likely cause collisions, rebuild always\n    this.constraints.unique[field] = index = new UniqueIndex(field);\n    this.data.forEach((obj) => {\n      index.set(obj);\n    });\n    return index;\n  }\n\n  /**\n\t * Ensure all binary indices\n\t */\n  ensureAllIndexes(force) {\n    let key;\n    const bIndices = this.binaryIndices;\n    for (key in bIndices) {\n      if (bIndices[key] !== undefined) {\n        this.ensureIndex(key, force);\n      }\n    }\n  }\n\n  flagBinaryIndexesDirty() {\n    let key;\n    const bIndices = this.binaryIndices;\n    for (key in bIndices) {\n      if (bIndices[key] !== undefined) {\n        bIndices[key].dirty = true;\n      }\n    }\n  }\n\n  flagBinaryIndexDirty(index) {\n    if (this.binaryIndices[index])\n      this.binaryIndices[index].dirty = true;\n  }\n\n  /**\n\t * Quickly determine number of documents in collection (or query)\n\t * @param {object=} query - (optional) query object to count results of\n\t * @returns {number} number of documents in the collection\n\t * @memberof Collection\n\t */\n  count(query) {\n    if (!query) {\n      return this.data.length;\n    }\n\n    return this.chain().find(query).filteredrows.length;\n  }\n\n  /**\n\t * Rebuild idIndex\n\t */\n  ensureId() {\n    const len = this.data.length;\n    let i = 0;\n\n    this.idIndex = [];\n    for (i; i < len; i += 1) {\n      this.idIndex.push(this.data[i].$loki);\n    }\n  }\n\n  /**\n\t * Add a dynamic view to the collection\n\t * @param {string} name - name of dynamic view to add\n\t * @param {object=} options - (optional) options to configure dynamic view with\n\t * @param {boolean} options.persistent - indicates if view is to main internal results array in 'resultdata'\n\t * @param {string} options.sortPriority - 'passive' (sorts performed on call to data) or 'active' (after updates)\n\t * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)\n\t * @returns {DynamicView} reference to the dynamic view added\n\t * @memberof Collection\n\t **/\n  addDynamicView(name, options) {\n    const dv = new DynamicView(this, name, options);\n    this._dynamicViews.push(dv);\n\n    return dv;\n  }\n\n  /**\n\t * Remove a dynamic view from the collection\n\t * @param {string} name - name of dynamic view to remove\n\t * @memberof Collection\n\t **/\n  removeDynamicView(name) {\n    for (let idx = 0; idx < this._dynamicViews.length; idx++) {\n      if (this._dynamicViews[idx].name === name) {\n        this._dynamicViews.splice(idx, 1);\n      }\n    }\n  }\n\n  /**\n\t * Look up dynamic view reference from within the collection\n\t * @param {string} name - name of dynamic view to retrieve reference of\n\t * @returns {DynamicView} A reference to the dynamic view with that name\n\t * @memberof Collection\n\t **/\n  getDynamicView(name) {\n    for (let idx = 0; idx < this._dynamicViews.length; idx++) {\n      if (this._dynamicViews[idx].name === name) {\n        return this._dynamicViews[idx];\n      }\n    }\n\n    return null;\n  }\n\n  /**\n\t * Applies a 'mongo-like' find query object and passes all results to an update function.\n\t * For filter function querying you should migrate to [\n\t * Where()]{@link Collection#updateWhere}.\n\t *\n\t * @param {object|function} filterObject - 'mongo-like' query object (or deprecated filterFunction mode)\n\t * @param {function} updateFunction - update function to run against filtered documents\n\t * @memberof Collection\n\t */\n  findAndUpdate(filterObject, updateFunction) {\n    if (typeof(filterObject) === \"function\") {\n      this.updateWhere(filterObject, updateFunction);\n    } else {\n      this.chain().find(filterObject).update(updateFunction);\n    }\n  }\n\n  /**\n\t * Applies a 'mongo-like' find query object removes all documents which match that filter.\n\t *\n\t * @param {object} filterObject - 'mongo-like' query object\n\t * @memberof Collection\n\t */\n  findAndRemove(filterObject) {\n    this.chain().find(filterObject).remove();\n  }\n\n  /**\n\t * Adds object(s) to collection, ensure object(s) have meta properties, clone it if necessary, etc.\n\t * @param {(object|array)} doc - the document (or array of documents) to be inserted\n\t * @returns {(object|array)} document or documents inserted\n\t * @memberof Collection\n\t */\n  insert(doc) {\n    if (!Array.isArray(doc)) {\n      return this.insertOne(doc);\n    }\n\n    // holder to the clone of the object inserted if collections is set to clone objects\n    let obj;\n    let results = [];\n\n    this.emit(\"pre-insert\", doc);\n    for (let i = 0, len = doc.length; i < len; i++) {\n      obj = this.insertOne(doc[i], true);\n      if (!obj) {\n        return undefined;\n      }\n      results.push(obj);\n    }\n    // at the 'batch' level, if clone option is true then emitted docs are clones\n    this.emit(\"insert\", results);\n\n    // if clone option is set, clone return values\n    results = this.cloneObjects ? clone(results, this.cloneMethod) : results;\n\n    return results.length === 1 ? results[0] : results;\n  }\n\n  /**\n\t * Adds a single object, ensures it has meta properties, clone it if necessary, etc.\n\t * @param {object} doc - the document to be inserted\n\t * @param {boolean} bulkInsert - quiet pre-insert and insert event emits\n\t * @returns {object} document or 'undefined' if there was a problem inserting it\n\t * @memberof Collection\n\t */\n  insertOne(doc, bulkInsert) {\n    let err = null;\n    let returnObj;\n\n    if (typeof doc !== \"object\") {\n      err = new TypeError(\"Document needs to be an object\");\n    } else if (doc === null) {\n      err = new TypeError(\"Object cannot be null\");\n    }\n\n    if (err !== null) {\n      this.emit(\"error\", err);\n      throw err;\n    }\n\n    // if configured to clone, do so now... otherwise just use same obj reference\n    const obj = this.cloneObjects ? clone(doc, this.cloneMethod) : doc;\n\n    if (typeof obj.meta === \"undefined\") {\n      obj.meta = {\n        revision: 0,\n        created: 0\n      };\n    }\n\n    // both 'pre-insert' and 'insert' events are passed internal data reference even when cloning\n    // insert needs internal reference because that is where loki itself listens to add meta\n    if (!bulkInsert) {\n      this.emit(\"pre-insert\", obj);\n    }\n    if (!this.add(obj)) {\n      return undefined;\n    }\n\n    // FullTextSearch TODO.\n    if (this._fullTextSearch !== null) {\n      this._fullTextSearch.addDocument(doc);\n    }\n\n    returnObj = obj;\n    if (!bulkInsert) {\n      this.emit(\"insert\", obj);\n      returnObj = this.cloneObjects ? clone(obj, this.cloneMethod) : obj;\n    }\n\n    this.addAutoUpdateObserver(returnObj);\n    return returnObj;\n  }\n\n  /**\n\t * Empties the collection.\n\t * @param {object=} options - configure clear behavior\n\t * @param {bool=} options.removeIndices - (default: false)\n\t * @memberof Collection\n\t */\n  clear(options) {\n    options = options || {};\n\n    this.data = [];\n    this.idIndex = [];\n    this.cachedIndex = null;\n    this.cachedBinaryIndex = null;\n    this.cachedData = null;\n    this.maxId = 0;\n    this._dynamicViews = [];\n    this.dirty = true;\n\n    // if removing indices entirely\n    if (options.removeIndices === true) {\n      this.binaryIndices = {};\n\n      this.constraints = {\n        unique: {},\n        exact: {}\n      };\n      this.uniqueNames = [];\n    }\n    // clear indices but leave definitions in place\n    else {\n      // clear binary indices\n      const keys = Object.keys(this.binaryIndices);\n      keys.forEach((biname) => {\n        this.binaryIndices[biname].dirty = false;\n        this.binaryIndices[biname].values = [];\n      });\n\n      // clear entire unique indices definition\n      this.constraints = {\n        unique: {},\n        exact: {}\n      };\n\n      // add definitions back\n      this.uniqueNames.forEach((uiname) => {\n        this.ensureUniqueIndex(uiname);\n      });\n    }\n  }\n\n  /**\n\t * Updates an object and notifies collection that the document has changed.\n\t * @param {object} doc - document to update within the collection\n\t * @memberof Collection\n\t */\n  update(doc) {\n    if (Array.isArray(doc)) {\n      let k = 0;\n      const len = doc.length;\n      for (k; k < len; k += 1) {\n        this.update(doc[k]);\n      }\n      return;\n    }\n\n    // verify object is a properly formed document\n    if (doc.$loki === undefined) {\n      throw new Error(\"Trying to update unsynced document. Please save the document first by using insert() or addMany()\");\n    }\n    try {\n      this.startTransaction();\n      const arr = this.get(doc.$loki, true);\n\n      // ref to existing obj\n      let oldInternal;\n\n      // ref to new internal obj\n      let newInternal;\n\n      let position;\n\n      if (!arr) {\n        throw new Error(\"Trying to update a document not in collection.\");\n      }\n\n      oldInternal = arr[0]; // -internal- obj ref\n      position = arr[1]; // position in data array\n\n      // if configured to clone, do so now... otherwise just use same obj reference\n      newInternal = this.cloneObjects ? clone(doc, this.cloneMethod) : doc;\n\n      this.emit(\"pre-update\", doc);\n\n      Object.keys(this.constraints.unique).forEach((key) => {\n        this.constraints.unique[key].update(oldInternal, newInternal);\n      });\n\n      // operate the update\n      this.data[position] = newInternal;\n\n      if (newInternal !== doc) {\n        this.addAutoUpdateObserver(doc);\n      }\n\n      // now that we can efficiently determine the data[] position of newly added document,\n      // submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n      for (let idx = 0; idx < this._dynamicViews.length; idx++) {\n        this._dynamicViews[idx].evaluateDocument(position, false);\n      }\n\n      let key;\n      if (this.adaptiveBinaryIndices) {\n        // for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n        const bIndices = this.binaryIndices;\n        for (key in bIndices) {\n          this.adaptiveBinaryIndexUpdate(position, key);\n        }\n      } else {\n        this.flagBinaryIndexesDirty();\n      }\n\n      this.idIndex[position] = newInternal.$loki;\n      //this.flagBinaryIndexesDirty();\n\n      // FullTextSearch.\n      if (this._fullTextSearch !== null) {\n        this._fullTextSearch.updateDocument(doc);\n      }\n\n      this.commit();\n      this.dirty = true; // for autosave scenarios\n\n      this.emit(\"update\", doc, this.cloneObjects ? clone(oldInternal, this.cloneMethod) : null);\n      return doc;\n    } catch (err) {\n      this.rollback();\n      this.console.error(err.message);\n      this.emit(\"error\", err);\n      throw (err); // re-throw error so user does not think it succeeded\n    }\n  }\n\n  /**\n\t * Add object to collection\n\t */\n  add(obj) {\n    // if parameter isn't object exit with throw\n    if (\"object\" !== typeof obj) {\n      throw new TypeError(\"Object being added needs to be an object\");\n    }\n    // if object you are adding already has id column it is either already in the collection\n    // or the object is carrying its own 'id' property.  If it also has a meta property,\n    // then this is already in collection so throw error, otherwise rename to originalId and continue adding.\n    if (typeof(obj.$loki) !== \"undefined\") {\n      throw new Error(\"Document is already in collection, please use update()\");\n    }\n\n    /*\n\t\t * try adding object to collection\n\t\t */\n    try {\n      this.startTransaction();\n      this.maxId++;\n\n      if (isNaN(this.maxId)) {\n        this.maxId = (this.data[this.data.length - 1].$loki + 1);\n      }\n\n      obj.$loki = this.maxId;\n      obj.meta.version = 0;\n\n      let key;\n      const constrUnique = this.constraints.unique;\n      for (key in constrUnique) {\n        if (constrUnique[key] !== undefined) {\n          constrUnique[key].set(obj);\n        }\n      }\n\n      // add new obj id to idIndex\n      this.idIndex.push(obj.$loki);\n\n      // add the object\n      this.data.push(obj);\n\n      const addedPos = this.data.length - 1;\n\n      // now that we can efficiently determine the data[] position of newly added document,\n      // submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n      const dvlen = this._dynamicViews.length;\n      for (let i = 0; i < dvlen; i++) {\n        this._dynamicViews[i].evaluateDocument(addedPos, true);\n      }\n\n      if (this.adaptiveBinaryIndices) {\n        // for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n        const bIndices = this.binaryIndices;\n        for (key in bIndices) {\n          this.adaptiveBinaryIndexInsert(addedPos, key);\n        }\n      } else {\n        this.flagBinaryIndexesDirty();\n      }\n\n      this.commit();\n      this.dirty = true; // for autosave scenarios\n\n      return (this.cloneObjects) ? (clone(obj, this.cloneMethod)) : (obj);\n    } catch (err) {\n      this.rollback();\n      this.console.error(err.message);\n      this.emit(\"error\", err);\n      throw (err); // re-throw error so user does not think it succeeded\n    }\n  }\n\n  /**\n\t * Applies a filter function and passes all results to an update function.\n\t *\n\t * @param {function} filterFunction - filter function whose results will execute update\n\t * @param {function} updateFunction - update function to run against filtered documents\n\t * @memberof Collection\n\t */\n  updateWhere(filterFunction, updateFunction) {\n    const results = this.where(filterFunction);\n    let i = 0;\n    let obj;\n    try {\n      for (i; i < results.length; i++) {\n        obj = updateFunction(results[i]);\n        this.update(obj);\n      }\n\n    } catch (err) {\n      this.rollback();\n      this.console.error(err.message);\n    }\n  }\n\n  /**\n\t * Remove all documents matching supplied filter function.\n\t * For 'mongo-like' querying you should migrate to [findAndRemove()]{@link Collection#findAndRemove}.\n\t * @param {function|object} query - query object to filter on\n\t * @memberof Collection\n\t */\n  removeWhere(query) {\n    let list;\n    if (typeof query === \"function\") {\n      list = this.data.filter(query);\n      this.remove(list);\n    } else {\n      this.chain().find(query).remove();\n    }\n  }\n\n  removeDataOnly() {\n    this.remove(this.data.slice());\n  }\n\n  /**\n\t * Remove a document from the collection\n\t * @param {object} doc - document to remove from collection\n\t * @memberof Collection\n\t */\n  remove(doc) {\n    if (typeof doc === \"number\") {\n      doc = this.get(doc);\n    }\n\n    if (\"object\" !== typeof doc) {\n      throw new Error(\"Parameter is not an object\");\n    }\n    if (Array.isArray(doc)) {\n      let k = 0;\n      const len = doc.length;\n      for (k; k < len; k += 1) {\n        this.remove(doc[k]);\n      }\n      return;\n    }\n\n    if (doc.$loki === undefined) {\n      throw new Error(\"Object is not a document stored in the collection\");\n    }\n\n    try {\n      this.startTransaction();\n      const arr = this.get(doc.$loki, true);\n\n      const // obj = arr[0],\n        position = arr[1];\n\n      Object.keys(this.constraints.unique).forEach((key) => {\n        if (doc[key] !== null && typeof doc[key] !== \"undefined\") {\n          this.constraints.unique[key].remove(doc[key]);\n        }\n      });\n      // now that we can efficiently determine the data[] position of newly added document,\n      // submit it for all registered DynamicViews to remove\n      for (let idx = 0; idx < this._dynamicViews.length; idx++) {\n        this._dynamicViews[idx].removeDocument(position);\n      }\n\n      if (this.adaptiveBinaryIndices) {\n        // for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n        let key;\n\n        const bIndices = this.binaryIndices;\n        for (key in bIndices) {\n          this.adaptiveBinaryIndexRemove(position, key);\n        }\n      } else {\n        this.flagBinaryIndexesDirty();\n      }\n\n      this.data.splice(position, 1);\n      this.removeAutoUpdateObserver(doc);\n\n      // remove id from idIndex\n      this.idIndex.splice(position, 1);\n\n      // FullTextSearch.\n      if (this._fullTextSearch != null) {\n        this._fullTextSearch.removeDocument(doc);\n      }\n\n      this.commit();\n      this.dirty = true; // for autosave scenarios\n      this.emit(\"delete\", arr[0]);\n      delete doc.$loki;\n      delete doc.meta;\n      return doc;\n    } catch (err) {\n      this.rollback();\n      this.console.error(err.message);\n      this.emit(\"error\", err);\n      return null;\n    }\n  }\n\n  /*---------------------+\n\t | Finding methods     |\n\t +----------------------*/\n\n  /**\n\t * Get by Id - faster than other methods because of the searching algorithm\n\t * @param {int} id - $loki id of document you want to retrieve\n\t * @param {boolean} returnPosition - if 'true' we will return [object, position]\n\t * @returns {(object|array|null)} Object reference if document was found, null if not,\n\t *     or an array if 'returnPosition' was passed.\n\t * @memberof Collection\n\t */\n  get(id, returnPosition) {\n    const retpos = returnPosition || false;\n    const data = this.idIndex;\n    let max = data.length - 1;\n    let min = 0;\n    let mid = (min + max) >> 1;\n\n    id = typeof id === \"number\" ? id : parseInt(id, 10);\n\n    if (isNaN(id)) {\n      throw new TypeError(\"Passed id is not an integer\");\n    }\n\n    while (data[min] < data[max]) {\n      mid = (min + max) >> 1;\n\n      if (data[mid] < id) {\n        min = mid + 1;\n      } else {\n        max = mid;\n      }\n    }\n\n    if (max === min && data[min] === id) {\n      if (retpos) {\n        return [this.data[min], min];\n      }\n      return this.data[min];\n    }\n    return null;\n  }\n\n  /**\n\t * Perform binary range lookup for the data[dataPosition][binaryIndexName] property value\n\t *    Since multiple documents may contain the same value (which the index is sorted on),\n\t *    we hone in on range and then linear scan range to find exact index array position.\n\t * @param {int} dataPosition : coll.data array index/position\n\t * @param {string} binaryIndexName : index to search for dataPosition in\n\t */\n  getBinaryIndexPosition(dataPosition, binaryIndexName) {\n    const val = this.data[dataPosition][binaryIndexName];\n    const index = this.binaryIndices[binaryIndexName].values;\n\n    // i think calculateRange can probably be moved to collection\n    // as it doesn't seem to need resultset.  need to verify\n    //let rs = new Resultset(this, null, null);\n    const range = this.calculateRange(\"$eq\", binaryIndexName, val);\n\n    if (range[0] === 0 && range[1] === -1) {\n      // uhoh didn't find range\n      return null;\n    }\n\n    const min = range[0];\n    const max = range[1];\n\n    // narrow down the sub-segment of index values\n    // where the indexed property value exactly matches our\n    // value and then linear scan to find exact -index- position\n    for (let idx = min; idx <= max; idx++) {\n      if (index[idx] === dataPosition) return idx;\n    }\n\n    // uhoh\n    return null;\n  }\n\n  /**\n\t * Adaptively insert a selected item to the index.\n\t * @param {int} dataPosition : coll.data array index/position\n\t * @param {string} binaryIndexName : index to search for dataPosition in\n\t */\n  adaptiveBinaryIndexInsert(dataPosition, binaryIndexName) {\n    const index = this.binaryIndices[binaryIndexName].values;\n    let val = this.data[dataPosition][binaryIndexName];\n\n    // If you are inserting a javascript Date value into a binary index, convert to epoch time\n    if (this.serializableIndices === true && val instanceof Date) {\n      this.data[dataPosition][binaryIndexName] = val.getTime();\n      val = this.data[dataPosition][binaryIndexName];\n    }\n\n    const idxPos = (index.length === 0) ? 0 : this.calculateRangeStart(binaryIndexName, val, true);\n\n    // insert new data index into our binary index at the proper sorted location for relevant property calculated by idxPos.\n    // doing this after adjusting dataPositions so no clash with previous item at that position.\n    this.binaryIndices[binaryIndexName].values.splice(idxPos, 0, dataPosition);\n  }\n\n  /**\n\t * Adaptively update a selected item within an index.\n\t * @param {int} dataPosition : coll.data array index/position\n\t * @param {string} binaryIndexName : index to search for dataPosition in\n\t */\n  adaptiveBinaryIndexUpdate(dataPosition, binaryIndexName) {\n    // linear scan needed to find old position within index unless we optimize for clone scenarios later\n    // within (my) node 5.6.0, the following for() loop with strict compare is -much- faster than indexOf()\n    let idxPos;\n\n    const index = this.binaryIndices[binaryIndexName].values;\n    const len = index.length;\n\n    for (idxPos = 0; idxPos < len; idxPos++) {\n      if (index[idxPos] === dataPosition) break;\n    }\n\n    //let idxPos = this.binaryIndices[binaryIndexName].values.indexOf(dataPosition);\n    this.binaryIndices[binaryIndexName].values.splice(idxPos, 1);\n\n    //this.adaptiveBinaryIndexRemove(dataPosition, binaryIndexName, true);\n    this.adaptiveBinaryIndexInsert(dataPosition, binaryIndexName);\n  }\n\n  /**\n\t * Adaptively remove a selected item from the index.\n\t * @param {int} dataPosition : coll.data array index/position\n\t * @param {string} binaryIndexName : index to search for dataPosition in\n\t */\n  adaptiveBinaryIndexRemove(dataPosition, binaryIndexName, removedFromIndexOnly) {\n    const idxPos = this.getBinaryIndexPosition(dataPosition, binaryIndexName);\n    const index = this.binaryIndices[binaryIndexName].values;\n    let len;\n    let idx;\n\n    if (idxPos === null) {\n      // throw new Error('unable to determine binary index position');\n      return null;\n    }\n\n    // remove document from index\n    this.binaryIndices[binaryIndexName].values.splice(idxPos, 1);\n\n    // if we passed this optional flag parameter, we are calling from adaptiveBinaryIndexUpdate,\n    // in which case data positions stay the same.\n    if (removedFromIndexOnly === true) {\n      return;\n    }\n\n    // since index stores data array positions, if we remove a document\n    // we need to adjust array positions -1 for all document positions greater than removed position\n    len = index.length;\n    for (idx = 0; idx < len; idx++) {\n      if (index[idx] > dataPosition) {\n        index[idx]--;\n      }\n    }\n  }\n\n  /**\n\t * Internal method used for index maintenance and indexed searching.\n\t * Calculates the beginning of an index range for a given value.\n\t * For index maintainance (adaptive:true), we will return a valid index position to insert to.\n\t * For querying (adaptive:false/undefined), we will :\n\t *    return lower bound/index of range of that value (if found)\n\t *    return next lower index position if not found (hole)\n\t * If index is empty it is assumed to be handled at higher level, so\n\t * this method assumes there is at least 1 document in index.\n\t *\n\t * @param {string} prop - name of property which has binary index\n\t * @param {any} val - value to find within index\n\t * @param {bool?} adaptive - if true, we will return insert position\n\t */\n  calculateRangeStart(prop, val, adaptive) {\n    const rcd = this.data;\n    const index = this.binaryIndices[prop].values;\n    let min = 0;\n    let max = index.length - 1;\n    let mid = 0;\n\n    if (index.length === 0) {\n      return -1;\n    }\n\n    // hone in on start position of value\n    while (min < max) {\n      mid = (min + max) >> 1;\n\n      if (ltHelper(rcd[index[mid]][prop], val, false)) {\n        min = mid + 1;\n      } else {\n        max = mid;\n      }\n    }\n\n    const lbound = min;\n\n    // found it... return it\n    if (aeqHelper(val, rcd[index[lbound]][prop])) {\n      return lbound;\n    }\n\n    // if not in index and our value is less than the found one\n    if (ltHelper(val, rcd[index[lbound]][prop], false)) {\n      return adaptive ? lbound : lbound - 1;\n    }\n\n    // not in index and our value is greater than the found one\n    return adaptive ? lbound + 1 : lbound;\n  }\n\n  /**\n\t * Internal method used for indexed $between.  Given a prop (index name), and a value\n\t * (which may or may not yet exist) this will find the final position of that upper range value.\n\t */\n  calculateRangeEnd(prop, val) {\n    const rcd = this.data;\n    const index = this.binaryIndices[prop].values;\n    let min = 0;\n    let max = index.length - 1;\n    let mid = 0;\n\n    if (index.length === 0) {\n      return -1;\n    }\n\n    // hone in on start position of value\n    while (min < max) {\n      mid = (min + max) >> 1;\n\n      if (ltHelper(val, rcd[index[mid]][prop], false)) {\n        max = mid;\n      } else {\n        min = mid + 1;\n      }\n    }\n\n    const ubound = max;\n\n    // only eq if last element in array is our val\n    if (aeqHelper(val, rcd[index[ubound]][prop])) {\n      return ubound;\n    }\n\n    // if not in index and our value is less than the found one\n    if (gtHelper(val, rcd[index[ubound]][prop], false)) {\n      return ubound + 1;\n    }\n\n    // either hole or first nonmatch\n    if (aeqHelper(val, rcd[index[ubound - 1]][prop])) {\n      return ubound - 1;\n    }\n\n    // hole, so ubound if nearest gt than the val we were looking for\n    return ubound;\n  }\n\n  /**\n\t * calculateRange() - Binary Search utility method to find range/segment of values matching criteria.\n\t *    this is used for collection.find() and first find filter of resultset/dynview\n\t *    slightly different than get() binary search in that get() hones in on 1 value,\n\t *    but we have to hone in on many (range)\n\t * @param {string} op - operation, such as $eq\n\t * @param {string} prop - name of property to calculate range for\n\t * @param {object} val - value to use for range calculation.\n\t * @returns {array} [start, end] index array positions\n\t */\n  calculateRange(op, prop, val) {\n    const rcd = this.data;\n    const index = this.binaryIndices[prop].values;\n    const min = 0;\n    const max = index.length - 1;\n    let lbound;\n    let lval;\n    let ubound;\n\n    // when no documents are in collection, return empty range condition\n    if (rcd.length === 0) {\n      return [0, -1];\n    }\n\n    const minVal = rcd[index[min]][prop];\n    const maxVal = rcd[index[max]][prop];\n\n    // if value falls outside of our range return [0, -1] to designate no results\n    switch (op) {\n      case \"$eq\":\n      case \"$aeq\":\n        if (ltHelper(val, minVal, false) || gtHelper(val, maxVal, false)) {\n          return [0, -1];\n        }\n        break;\n      case \"$dteq\":\n        if (ltHelper(val, minVal, false) || gtHelper(val, maxVal, false)) {\n          return [0, -1];\n        }\n        break;\n      case \"$gt\":\n        // none are within range\n        if (gtHelper(val, maxVal, true)) {\n          return [0, -1];\n        }\n        // all are within range\n        if (gtHelper(minVal, val, false)) {\n          return [min, max];\n        }\n        break;\n      case \"$gte\":\n        // none are within range\n        if (gtHelper(val, maxVal, false)) {\n          return [0, -1];\n        }\n        // all are within range\n        if (gtHelper(minVal, val, true)) {\n          return [min, max];\n        }\n        break;\n      case \"$lt\":\n        // none are within range\n        if (ltHelper(val, minVal, true)) {\n          return [0, -1];\n        }\n        // all are within range\n        if (ltHelper(maxVal, val, false)) {\n          return [min, max];\n        }\n        break;\n      case \"$lte\":\n        // none are within range\n        if (ltHelper(val, minVal, false)) {\n          return [0, -1];\n        }\n        // all are within range\n        if (ltHelper(maxVal, val, true)) {\n          return [min, max];\n        }\n        break;\n      case \"$between\":\n        // none are within range (low range is greater)\n        if (gtHelper(val[0], maxVal, false)) {\n          return [0, -1];\n        }\n        // none are within range (high range lower)\n        if (ltHelper(val[1], minVal, false)) {\n          return [0, -1];\n        }\n\n        lbound = this.calculateRangeStart(prop, val[0]);\n        ubound = this.calculateRangeEnd(prop, val[1]);\n\n        if (lbound < 0) lbound++;\n        if (ubound > max) ubound--;\n\n        if (!gtHelper(rcd[index[lbound]][prop], val[0], true)) lbound++;\n        if (!ltHelper(rcd[index[ubound]][prop], val[1], true)) ubound--;\n\n        if (ubound < lbound) return [0, -1];\n\n        return ([lbound, ubound]);\n      case \"$in\": {\n        const idxset = [];\n        const segResult = [];\n        // query each value '$eq' operator and merge the seqment results.\n        for (let j = 0, len = val.length; j < len; j++) {\n          const seg = this.calculateRange(\"$eq\", prop, val[j]);\n\n          for (let i = seg[0]; i <= seg[1]; i++) {\n            if (idxset[i] === undefined) {\n              idxset[i] = true;\n              segResult.push(i);\n            }\n          }\n        }\n        return segResult;\n      }\n    }\n\n    // determine lbound where needed\n    switch (op) {\n      case \"$eq\":\n      case \"$aeq\":\n      case \"$dteq\":\n      case \"$gte\":\n      case \"$lt\":\n        lbound = this.calculateRangeStart(prop, val);\n        lval = rcd[index[lbound]][prop];\n        break;\n      default:\n        break;\n    }\n\n    // determine ubound where needed\n    switch (op) {\n      case \"$eq\":\n      case \"$aeq\":\n      case \"$dteq\":\n      case \"$lte\":\n      case \"$gt\":\n        ubound = this.calculateRangeEnd(prop, val);\n        break;\n      default:\n        break;\n    }\n\n\n    switch (op) {\n      case \"$eq\":\n      case \"$aeq\":\n      case \"$dteq\":\n        // if hole (not found)\n        //if (ltHelper(lval, val, false) || gtHelper(lval, val, false)) {\n        //  return [0, -1];\n        //}\n        if (!aeqHelper(lval, val)) {\n          return [0, -1];\n        }\n\n        return [lbound, ubound];\n\n        //case '$dteq':\n        // if hole (not found)\n        //  if (lval > val || lval < val) {\n        //    return [0, -1];\n        //  }\n\n        //  return [lbound, ubound];\n\n      case \"$gt\":\n        // (an eqHelper would probably be better test)\n        // if hole (not found) ub position is already greater\n        if (!aeqHelper(rcd[index[ubound]][prop], val)) {\n          //if (gtHelper(rcd[index[ubound]][prop], val, false)) {\n          return [ubound, max];\n        }\n        // otherwise (found) so ubound is still equal, get next\n        return [ubound + 1, max];\n\n      case \"$gte\":\n        // if hole (not found) lb position marks left outside of range\n        if (!aeqHelper(rcd[index[lbound]][prop], val)) {\n          //if (ltHelper(rcd[index[lbound]][prop], val, false)) {\n          return [lbound + 1, max];\n        }\n        // otherwise (found) so lb is first position where its equal\n        return [lbound, max];\n\n      case \"$lt\":\n        // if hole (not found) position already is less than\n        if (!aeqHelper(rcd[index[lbound]][prop], val)) {\n          //if (ltHelper(rcd[index[lbound]][prop], val, false)) {\n          return [min, lbound];\n        }\n        // otherwise (found) so lb marks left inside of eq range, get previous\n        return [min, lbound - 1];\n\n      case \"$lte\":\n        // if hole (not found) ub position marks right outside so get previous\n        if (!aeqHelper(rcd[index[ubound]][prop], val)) {\n          //if (gtHelper(rcd[index[ubound]][prop], val, false)) {\n          return [min, ubound - 1];\n        }\n        // otherwise (found) so ub is last position where its still equal\n        return [min, ubound];\n\n      default:\n        return [0, rcd.length - 1];\n    }\n  }\n\n  /**\n\t * Retrieve doc by Unique index\n\t * @param {string} field - name of uniquely indexed property to use when doing lookup\n\t * @param {value} value - unique value to search for\n\t * @returns {object} document matching the value passed\n\t * @memberof Collection\n\t */\n  by(field, value) {\n    if (value === undefined) {\n      return (value) => this.by(field, value);\n    }\n\n    const result = this.constraints.unique[field].get(value);\n    if (!this.cloneObjects) {\n      return result;\n    } else {\n      return clone(result, this.cloneMethod);\n    }\n  }\n\n  /**\n\t * Find one object by index property, by property equal to value\n\t * @param {object} query - query object used to perform search with\n\t * @returns {(object|null)} First matching document, or null if none\n\t * @memberof Collection\n\t */\n  findOne(query) {\n    query = query || {};\n\n    // Instantiate Resultset and exec find op passing firstOnly = true param\n    const result = this.chain().find(query, true).data();\n\n    if (Array.isArray(result) && result.length === 0) {\n      return null;\n    } else {\n      if (!this.cloneObjects) {\n        return result[0];\n      } else {\n        return clone(result[0], this.cloneMethod);\n      }\n    }\n  }\n\n  /**\n\t * Chain method, used for beginning a series of chained find() and/or view() operations\n\t * on a collection.\n\t *\n\t * @param {array} transform - Ordered array of transform step objects similar to chain\n\t * @param {object} parameters - Object containing properties representing parameters to substitute\n\t * @returns {Resultset} (this) resultset, or data array if any map or join functions where called\n\t * @memberof Collection\n\t */\n  chain(transform, parameters) {\n    const rs = new Resultset(this);\n\n    if (typeof transform === \"undefined\") {\n      return rs;\n    }\n\n    return rs.transform(transform, parameters);\n  }\n\n  /**\n\t * Find method, api is similar to mongodb.\n\t * for more complex queries use [chain()]{@link Collection#chain} or [where()]{@link Collection#where}.\n\t * @example {@tutorial Query Examples}\n\t * @param {object} query - 'mongo-like' query object\n\t * @returns {array} Array of matching documents\n\t * @memberof Collection\n\t */\n  find(query) {\n    return this.chain().find(query).data();\n  }\n\n  /**\n\t * Find object by unindexed field by property equal to value,\n\t * simply iterates and returns the first element matching the query\n\t */\n  findOneUnindexed(prop, value) {\n    let i = this.data.length;\n    let doc;\n    while (i--) {\n      if (this.data[i][prop] === value) {\n        doc = this.data[i];\n        return doc;\n      }\n    }\n    return null;\n  }\n\n  /**\n\t * Transaction methods\n\t */\n\n  /** start the transation */\n  startTransaction() {\n    if (this.transactional) {\n      this.cachedData = clone(this.data, this.cloneMethod);\n      this.cachedIndex = this.idIndex;\n      this.cachedBinaryIndex = this.binaryIndices;\n\n      // propagate startTransaction to dynamic views\n      for (let idx = 0; idx < this._dynamicViews.length; idx++) {\n        this._dynamicViews[idx].startTransaction();\n      }\n    }\n  }\n\n  /** commit the transation */\n  commit() {\n    if (this.transactional) {\n      this.cachedData = null;\n      this.cachedIndex = null;\n      this.cachedBinaryIndex = null;\n\n      // propagate commit to dynamic views\n      for (let idx = 0; idx < this._dynamicViews.length; idx++) {\n        this._dynamicViews[idx].commit();\n      }\n    }\n  }\n\n  /** roll back the transation */\n  rollback() {\n    if (this.transactional) {\n      if (this.cachedData !== null && this.cachedIndex !== null) {\n        this.data = this.cachedData;\n        this.idIndex = this.cachedIndex;\n        this.binaryIndices = this.cachedBinaryIndex;\n      }\n\n      // propagate rollback to dynamic views\n      for (let idx = 0; idx < this._dynamicViews.length; idx++) {\n        this._dynamicViews[idx].rollback();\n      }\n    }\n  }\n\n  /**\n\t * Query the collection by supplying a javascript filter function.\n\t * @example\n\t * let results = coll.where(function(obj) {\n\t *   return obj.legs === 8;\n\t * });\n\t *\n\t * @param {function} fun - filter function to run against all collection docs\n\t * @returns {array} all documents which pass your filter function\n\t * @memberof Collection\n\t */\n  where(fun) {\n    return this.chain().where(fun).data();\n  }\n\n  /**\n\t * Map Reduce operation\n\t *\n\t * @param {function} mapFunction - function to use as map function\n\t * @param {function} reduceFunction - function to use as reduce function\n\t * @returns {data} The result of your mapReduce operation\n\t * @memberof Collection\n\t */\n  mapReduce(mapFunction, reduceFunction) {\n    try {\n      return reduceFunction(this.data.map(mapFunction));\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  /**\n\t * Join two collections on specified properties\n\t *\n\t * @param {array} joinData - array of documents to 'join' to this collection\n\t * @param {string} leftJoinProp - property name in collection\n\t * @param {string} rightJoinProp - property name in joinData\n\t * @param {function=} mapFun - (Optional) map function to use\n\t * @returns {Resultset} Result of the mapping operation\n\t * @memberof Collection\n\t */\n  eqJoin(joinData, leftJoinProp, rightJoinProp, mapFun) {\n    // logic in Resultset class\n    return new Resultset(this).eqJoin(joinData, leftJoinProp, rightJoinProp, mapFun);\n  }\n\n  /* ------ STAGING API -------- */\n  /**\n\t * stages: a map of uniquely identified 'stages', which hold copies of objects to be\n\t * manipulated without affecting the data in the original collection\n\t */\n\n\n  /**\n\t * (Staging API) create a stage and/or retrieve it\n\t * @memberof Collection\n\t */\n  getStage(name) {\n    if (!this.stages[name]) {\n      this.stages[name] = {};\n    }\n    return this.stages[name];\n  }\n\n  /**\n\t * a collection of objects recording the changes applied through a commmitStage\n\t */\n\n  /**\n\t * (Staging API) create a copy of an object and insert it into a stage\n\t * @memberof Collection\n\t */\n  stage(stageName, obj) {\n    const copy = JSON.parse(JSON.stringify(obj));\n    this.getStage(stageName)[obj.$loki] = copy;\n    return copy;\n  }\n\n  /**\n\t * (Staging API) re-attach all objects to the original collection, so indexes and views can be rebuilt\n\t * then create a message to be inserted in the commitlog\n\t * @param {string} stageName - name of stage\n\t * @param {string} message\n\t * @memberof Collection\n\t */\n  commitStage(stageName, message) {\n    const stage = this.getStage(stageName);\n    let prop;\n    const timestamp = new Date().getTime();\n\n    for (prop in stage) {\n\n      this.update(stage[prop]);\n      this.commitLog.push({\n        timestamp,\n        message,\n        data: JSON.parse(JSON.stringify(stage[prop]))\n      });\n    }\n    this.stages[stageName] = {};\n  }\n\n  no_op() {\n    return;\n  }\n\n  /**\n\t * @memberof Collection\n\t */\n  extract(field) {\n    let i = 0;\n    const len = this.data.length;\n    const isDotNotation = isDeepProperty(field);\n    const result = [];\n    for (i; i < len; i += 1) {\n      result.push(deepProperty(this.data[i], field, isDotNotation));\n    }\n    return result;\n  }\n\n  /**\n\t * @memberof Collection\n\t */\n  max(field) {\n    return Math.max.apply(null, this.extract(field));\n  }\n\n  /**\n\t * @memberof Collection\n\t */\n  min(field) {\n    return Math.min.apply(null, this.extract(field));\n  }\n\n  /**\n\t * @memberof Collection\n\t */\n  maxRecord(field) {\n    let i = 0;\n    const len = this.data.length;\n    const deep = isDeepProperty(field);\n\n    const result = {\n      index: 0,\n      value: undefined\n    };\n\n    let max;\n\n    for (i; i < len; i += 1) {\n      if (max !== undefined) {\n        if (max < deepProperty(this.data[i], field, deep)) {\n          max = deepProperty(this.data[i], field, deep);\n          result.index = this.data[i].$loki;\n        }\n      } else {\n        max = deepProperty(this.data[i], field, deep);\n        result.index = this.data[i].$loki;\n      }\n    }\n    result.value = max;\n    return result;\n  }\n\n  /**\n\t * @memberof Collection\n\t */\n  minRecord(field) {\n    let i = 0;\n    const len = this.data.length;\n    const deep = isDeepProperty(field);\n\n    const result = {\n      index: 0,\n      value: undefined\n    };\n\n    let min;\n\n    for (i; i < len; i += 1) {\n      if (min !== undefined) {\n        if (min > deepProperty(this.data[i], field, deep)) {\n          min = deepProperty(this.data[i], field, deep);\n          result.index = this.data[i].$loki;\n        }\n      } else {\n        min = deepProperty(this.data[i], field, deep);\n        result.index = this.data[i].$loki;\n      }\n    }\n    result.value = min;\n    return result;\n  }\n\n  /**\n\t * @memberof Collection\n\t */\n  extractNumerical(field) {\n    return this.extract(field).map(parseBase10).filter(Number).filter((n) => !(isNaN(n)));\n  }\n\n  /**\n\t * Calculates the average numerical value of a property\n\t *\n\t * @param {string} field - name of property in docs to average\n\t * @returns {number} average of property in all docs in the collection\n\t * @memberof Collection\n\t */\n  avg(field) {\n    return average(this.extractNumerical(field));\n  }\n\n  /**\n\t * Calculate standard deviation of a field\n\t * @memberof Collection\n\t * @param {string} field\n\t */\n  stdDev(field) {\n    return standardDeviation(this.extractNumerical(field));\n  }\n\n  /**\n\t * @memberof Collection\n\t * @param {string} field\n\t */\n  mode(field) {\n    const dict = {};\n    const data = this.extract(field);\n    data.forEach((obj) => {\n      if (dict[obj]) {\n        dict[obj] += 1;\n      } else {\n        dict[obj] = 1;\n      }\n    });\n    let max;\n    let prop;\n    let mode;\n    for (prop in dict) {\n      if (max) {\n        if (max < dict[prop]) {\n          mode = prop;\n        }\n      } else {\n        mode = prop;\n        max = dict[prop];\n      }\n    }\n    return mode;\n  }\n\n  /**\n\t * @memberof Collection\n\t * @param {string} field - property name\n\t */\n  median(field) {\n    const values = this.extractNumerical(field);\n    values.sort(sub);\n\n    const half = Math.floor(values.length / 2);\n\n    if (values.length % 2) {\n      return values[half];\n    } else {\n      return (values[half - 1] + values[half]) / 2.0;\n    }\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/loki/src/collection.js\n// module id = 2\n// module chunks = 0","import {clone} from \"./clone\";\nimport {Collection} from \"./collection\";\nimport {resolveTransformParams} from \"./utils\";\nimport {ltHelper, gtHelper, aeqHelper, sortHelper} from \"./helper\";\n\n/*\n 'Utils' is not defined                 no-undef\t(resolveTransformParams)\n 'sortHelper' is not defined            no-undef\n 'compoundeval' is not defined          no-undef\n 'indexedOpsList' is not defined        no-undef\n 'LokiOps' is not defined               no-undef\n 'dotSubScan' is not defined            no-undef\n 'clone' is not defined                 no-undef\n\n\n */\n\nfunction containsCheckFn(a) {\n  if (typeof a === \"string\" || Array.isArray(a)) {\n    return (b) => a.indexOf(b) !== -1;\n  } else if (typeof a === \"object\" && a !== null) {\n    return (b) => hasOwnProperty.call(a, b);\n  }\n  return null;\n}\n\nfunction doQueryOp(val, op) {\n  for (let p in op) {\n    if (hasOwnProperty.call(op, p)) {\n      return LokiOps[p](val, op[p]);\n    }\n  }\n  return false;\n}\n\n\nexport const LokiOps = {\n  // comparison operators\n  // a is the value in the collection\n  // b is the query value\n  $eq(a, b) {\n    return a === b;\n  },\n\n  // abstract/loose equality\n  $aeq(a, b) {\n    return a == b;\n  },\n\n  $ne(a, b) {\n    // ecma 5 safe test for NaN\n    if (b !== b) {\n      // ecma 5 test value is not NaN\n      return (a === a);\n    }\n\n    return a !== b;\n  },\n\n  // date equality / loki abstract equality test\n  $dteq(a, b) {\n    return aeqHelper(a, b);\n  },\n\n  $gt(a, b) {\n    return gtHelper(a, b, false);\n  },\n\n  $gte(a, b) {\n    return gtHelper(a, b, true);\n  },\n\n  $lt(a, b) {\n    return ltHelper(a, b, false);\n  },\n\n  $lte(a, b) {\n    return ltHelper(a, b, true);\n  },\n\n  // ex : coll.find({'orderCount': {$between: [10, 50]}});\n  $between(a, vals) {\n    if (a === undefined || a === null) return false;\n    return (gtHelper(a, vals[0], true) && ltHelper(a, vals[1], true));\n  },\n\n  $in(a, b) {\n    return b.indexOf(a) !== -1;\n  },\n\n  $nin(a, b) {\n    return b.indexOf(a) === -1;\n  },\n\n  $keyin(a, b) {\n    return a in b;\n  },\n\n  $nkeyin(a, b) {\n    return !(a in b);\n  },\n\n  $definedin(a, b) {\n    return b[a] !== undefined;\n  },\n\n  $undefinedin(a, b) {\n    return b[a] === undefined;\n  },\n\n  $regex(a, b) {\n    return b.test(a);\n  },\n\n  $containsString(a, b) {\n    return (typeof a === \"string\") && (a.indexOf(b) !== -1);\n  },\n\n  $containsNone(a, b) {\n    return !LokiOps.$containsAny(a, b);\n  },\n\n  $containsAny(a, b) {\n    const checkFn = containsCheckFn(a);\n    if (checkFn !== null) {\n      return (Array.isArray(b)) ? (b.some(checkFn)) : (checkFn(b));\n    }\n    return false;\n  },\n\n  $contains(a, b) {\n    const checkFn = containsCheckFn(a);\n    if (checkFn !== null) {\n      return (Array.isArray(b)) ? (b.every(checkFn)) : (checkFn(b));\n    }\n    return false;\n  },\n\n  $type(a, b) {\n    let type = typeof a;\n    if (type === \"object\") {\n      if (Array.isArray(a)) {\n        type = \"array\";\n      } else if (a instanceof Date) {\n        type = \"date\";\n      }\n    }\n    return (typeof b !== \"object\") ? (type === b) : doQueryOp(type, b);\n  },\n\n  $finite(a, b) {\n    return (b === isFinite(a));\n  },\n\n  $size(a, b) {\n    if (Array.isArray(a)) {\n      return (typeof b !== \"object\") ? (a.length === b) : doQueryOp(a.length, b);\n    }\n    return false;\n  },\n\n  $len(a, b) {\n    if (typeof a === \"string\") {\n      return (typeof b !== \"object\") ? (a.length === b) : doQueryOp(a.length, b);\n    }\n    return false;\n  },\n\n  $where(a, b) {\n    return b(a) === true;\n  },\n\n  // field-level logical operators\n  // a is the value in the collection\n  // b is the nested query operation (for '$not')\n  //   or an array of nested query operations (for '$and' and '$or')\n  $not(a, b) {\n    return !doQueryOp(a, b);\n  },\n\n  $and(a, b) {\n    for (let idx = 0, len = b.length; idx < len; idx += 1) {\n      if (!doQueryOp(a, b[idx])) {\n        return false;\n      }\n    }\n    return true;\n  },\n\n  $or(a, b) {\n    for (let idx = 0, len = b.length; idx < len; idx += 1) {\n      if (doQueryOp(a, b[idx])) {\n        return true;\n      }\n    }\n    return false;\n  }\n};\n\n// if an op is registered in this object, our 'calculateRange' can use it with our binary indices.\n// if the op is registered to a function, we will run that function/op as a 2nd pass filter on results.\n// those 2nd pass filter functions should be similar to LokiOps functions, accepting 2 vals to compare.\nconst indexedOps = {\n  $eq: LokiOps.$eq,\n  $aeq: true,\n  $dteq: true,\n  $gt: true,\n  $gte: true,\n  $lt: true,\n  $lte: true,\n  $in: true,\n  $between: true\n};\n\n/**\n * compoundeval() - helper function for compoundsort(), performing individual object comparisons\n *\n * @param {array} properties - array of property names, in order, by which to evaluate sort order\n * @param {object} obj1 - first object to compare\n * @param {object} obj2 - second object to compare\n * @returns {integer} 0, -1, or 1 to designate if identical (sortwise) or which should be first\n */\nfunction compoundeval(properties, obj1, obj2) {\n  let res = 0;\n  let prop;\n  let field;\n  for (let i = 0, len = properties.length; i < len; i++) {\n    prop = properties[i];\n    field = prop[0];\n    res = sortHelper(obj1[field], obj2[field], prop[1]);\n    if (res !== 0) {\n      return res;\n    }\n  }\n  return 0;\n}\n\n\n/**\n * dotSubScan - helper function used for dot notation queries.\n *\n * @param {object} root - object to traverse\n * @param {array} paths - array of properties to drill into\n * @param {function} fun - evaluation function to test with\n * @param {any} value - comparative value to also pass to (compare) fun\n * @param {number} poffset - index of the item in 'paths' to start the sub-scan from\n */\nfunction dotSubScan(root, paths, fun, value, poffset) {\n  const pathOffset = poffset || 0;\n  const path = paths[pathOffset];\n  if (root === undefined || root === null || root[path] === undefined) {\n    return false;\n  }\n\n  let valueFound = false;\n  const element = root[path];\n  if (pathOffset + 1 >= paths.length) {\n    // if we have already expanded out the dot notation,\n    // then just evaluate the test function and value on the element\n    valueFound = fun(element, value);\n  } else if (Array.isArray(element)) {\n    for (let index = 0, len = element.length; index < len; index += 1) {\n      valueFound = dotSubScan(element[index], paths, fun, value, pathOffset + 1);\n      if (valueFound === true) {\n        break;\n      }\n    }\n  } else {\n    valueFound = dotSubScan(element, paths, fun, value, pathOffset + 1);\n  }\n\n  return valueFound;\n}\n\n/**\n * Resultset class allowing chainable queries.  Intended to be instanced internally.\n *    Collection.find(), Collection.where(), and Collection.chain() instantiate this.\n *\n * @example\n *    mycollection.chain()\n *      .find({ 'doors' : 4 })\n *      .where(function(obj) { return obj.name === 'Toyota' })\n *      .data();\n */\nexport class Resultset {\n  /**\n   * Constructor.\n   * @param {Collection} collection - the collection which this Resultset will query against\n   * @returns {Resultset}\n   */\n  constructor(collection) {\n    // retain reference to collection we are querying against\n    this.collection = collection;\n    this.filteredrows = [];\n    this.filterInitialized = false;\n  }\n\n  /**\n   * reset() - Reset the resultset to its initial state.\n   *\n   * @returns {Resultset} Reference to this resultset, for future chain operations.\n   */\n  reset() {\n    if (this.filteredrows.length > 0) {\n      this.filteredrows = [];\n    }\n    this.filterInitialized = false;\n    return this;\n  }\n\n  /**\n   * toJSON() - Override of toJSON to avoid circular references\n   *\n   */\n  toJSON() {\n    const copy = this.copy();\n    copy.collection = null;\n    return copy;\n  }\n\n  /**\n   * Allows you to limit the number of documents passed to next chain operation.\n   *    A resultset copy() is made to avoid altering original resultset.\n   *\n   * @param {int} qty - The number of documents to return.\n   * @returns {Resultset} Returns a copy of the resultset, limited by qty, for subsequent chain ops.\n   */\n  limit(qty) {\n    // if this has no filters applied, we need to populate filteredrows first\n    if (!this.filterInitialized && this.filteredrows.length === 0) {\n      this.filteredrows = this.collection.prepareFullDocIndex();\n    }\n\n    this.filteredrows = this.filteredrows.slice(0, qty);\n    this.filterInitialized = true;\n    return this;\n  }\n\n  /**\n   * Used for skipping 'pos' number of documents in the resultset.\n   *\n   * @param {int} pos - Number of documents to skip; all preceding documents are filtered out.\n   * @returns {Resultset} Returns a copy of the resultset, containing docs starting at 'pos' for subsequent chain ops.\n   */\n  offset(pos) {\n    // if this has no filters applied, we need to populate filteredrows first\n    if (!this.filterInitialized && this.filteredrows.length === 0) {\n      this.filteredrows = this.collection.prepareFullDocIndex();\n    }\n\n    this.filteredrows = this.filteredrows.slice(pos);\n    this.filterInitialized = true;\n    return this;\n  }\n\n  /**\n   * copy() - To support reuse of resultset in branched query situations.\n   *\n   * @returns {Resultset} Returns a copy of the resultset (set) but the underlying document references will be the same.\n   */\n  copy() {\n    const result = new Resultset(this.collection);\n\n    if (this.filteredrows.length > 0) {\n      result.filteredrows = this.filteredrows.slice();\n    }\n    result.filterInitialized = this.filterInitialized;\n\n    return result;\n  }\n\n  /**\n   * Alias of copy()\n   */\n  branch() {\n    return this.copy();\n  }\n\n  /**\n   * transform() - executes a named collection transform or raw array of transform steps against the resultset.\n   *\n   * @param transform {(string|array)} - name of collection transform or raw transform array\n   * @param parameters {object=} - (Optional) object property hash of parameters, if the transform requires them.\n   * @returns {Resultset} either (this) resultset or a clone of of this resultset (depending on steps)\n   */\n  transform(transform, parameters) {\n    let idx;\n    let step;\n    let rs = this;\n\n    // if transform is name, then do lookup first\n    if (typeof transform === \"string\") {\n      if (this.collection.transforms[transform] !== undefined) {\n        transform = this.collection.transforms[transform];\n      }\n    }\n\n    // either they passed in raw transform array or we looked it up, so process\n    if (typeof transform !== \"object\" || !Array.isArray(transform)) {\n      throw new Error(\"Invalid transform\");\n    }\n\n    if (typeof parameters !== \"undefined\") {\n      transform = resolveTransformParams(transform, parameters);\n    }\n\n    for (idx = 0; idx < transform.length; idx++) {\n      step = transform[idx];\n\n      switch (step.type) {\n        case \"find\":\n          rs.find(step.value);\n          break;\n        case \"where\":\n          rs.where(step.value);\n          break;\n        case \"simplesort\":\n          rs.simplesort(step.property, step.desc);\n          break;\n        case \"compoundsort\":\n          rs.compoundsort(step.value);\n          break;\n        case \"sort\":\n          rs.sort(step.value);\n          break;\n        case \"limit\":\n          rs = rs.limit(step.value);\n          break; // limit makes copy so update reference\n        case \"offset\":\n          rs = rs.offset(step.value);\n          break; // offset makes copy so update reference\n        case \"map\":\n          rs = rs.map(step.value);\n          break;\n        case \"eqJoin\":\n          rs = rs.eqJoin(step.joinData, step.leftJoinKey, step.rightJoinKey, step.mapFun);\n          break;\n        // following cases break chain by returning array data so make any of these last in transform steps\n        case \"mapReduce\":\n          rs = rs.mapReduce(step.mapFunction, step.reduceFunction);\n          break;\n        // following cases update documents in current filtered resultset (use carefully)\n        case \"update\":\n          rs.update(step.value);\n          break;\n        case \"remove\":\n          rs.remove();\n          break;\n        default:\n          break;\n      }\n    }\n\n    return rs;\n  }\n\n  /**\n   * User supplied compare function is provided two documents to compare. (chainable)\n   * @example\n   *    rslt.sort(function(obj1, obj2) {\n\t *      if (obj1.name === obj2.name) return 0;\n\t *      if (obj1.name > obj2.name) return 1;\n\t *      if (obj1.name < obj2.name) return -1;\n\t *    });\n   *\n   * @param {function} comparefun - A javascript compare function used for sorting.\n   * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n   */\n  sort(comparefun) {\n    // if this has no filters applied, just we need to populate filteredrows first\n    if (!this.filterInitialized && this.filteredrows.length === 0) {\n      this.filteredrows = this.collection.prepareFullDocIndex();\n    }\n\n    const wrappedComparer =\n      (((userComparer, data) => (a, b) => userComparer(data[a], data[b])))(comparefun, this.collection.data);\n\n    this.filteredrows.sort(wrappedComparer);\n\n    return this;\n  }\n\n  /**\n   * Simpler, loose evaluation for user to sort based on a property name. (chainable).\n   *    Sorting based on the same lt/gt helper functions used for binary indices.\n   *\n   * @param {string} propname - name of property to sort by.\n   * @param {bool=} isdesc - (Optional) If true, the property will be sorted in descending order\n   * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n   */\n  simplesort(propname, isdesc) {\n    if (typeof (isdesc) === \"undefined\") {\n      isdesc = false;\n    }\n\n    // if this has no filters applied, just we need to populate filteredrows first\n    if (!this.filterInitialized && this.filteredrows.length === 0) {\n      // if we have a binary index and no other filters applied, we can use that instead of sorting (again)\n      if (this.collection.binaryIndices[propname] !== undefined) {\n        // make sure index is up-to-date\n        this.collection.ensureIndex(propname);\n        // copy index values into filteredrows\n        this.filteredrows = this.collection.binaryIndices[propname].values.slice(0);\n\n        if (isdesc) {\n          this.filteredrows.reverse();\n        }\n\n        // we are done, return this (resultset) for further chain ops\n        return this;\n      }\n      // otherwise initialize array for sort below\n      else {\n        this.filteredrows = this.collection.prepareFullDocIndex();\n      }\n    }\n\n    const wrappedComparer =\n      (((prop, desc, data) => (a, b) => sortHelper(data[a][prop], data[b][prop], desc)))(propname, isdesc, this.collection.data);\n\n    this.filteredrows.sort(wrappedComparer);\n\n    return this;\n  }\n\n  /**\n   * Allows sorting a resultset based on multiple columns.\n   * @example\n   * // to sort by age and then name (both ascending)\n   * rs.compoundsort(['age', 'name']);\n   * // to sort by age (ascending) and then by name (descending)\n   * rs.compoundsort(['age', ['name', true]);\n   *\n   * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n   * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n   */\n  compoundsort(properties) {\n    if (properties.length === 0) {\n      throw new Error(\"Invalid call to compoundsort, need at least one property\");\n    }\n\n    let prop;\n    if (properties.length === 1) {\n      prop = properties[0];\n      if (Array.isArray(prop)) {\n        return this.simplesort(prop[0], prop[1]);\n      }\n      return this.simplesort(prop, false);\n    }\n\n    // unify the structure of 'properties' to avoid checking it repeatedly while sorting\n    for (let i = 0, len = properties.length; i < len; i += 1) {\n      prop = properties[i];\n      if (!Array.isArray(prop)) {\n        properties[i] = [prop, false];\n      }\n    }\n\n    // if this has no filters applied, just we need to populate filteredrows first\n    if (!this.filterInitialized && this.filteredrows.length === 0) {\n      this.filteredrows = this.collection.prepareFullDocIndex();\n    }\n\n    const wrappedComparer =\n      (((props, data) => (a, b) => compoundeval(props, data[a], data[b])))(properties, this.collection.data);\n\n    this.filteredrows.sort(wrappedComparer);\n\n    return this;\n  }\n\n  /**\n   * findOr() - oversee the operation of OR'ed query expressions.\n   *    OR'ed expression evaluation runs each expression individually against the full collection,\n   *    and finally does a set OR on each expression's results.\n   *    Each evaluation can utilize a binary index to prevent multiple linear array scans.\n   *\n   * @param {array} expressionArray - array of expressions\n   * @returns {Resultset} this resultset for further chain ops.\n   */\n  findOr(expressionArray) {\n    let fr = null;\n    let fri = 0;\n    let frlen = 0;\n    const docset = [];\n    const idxset = [];\n    let idx = 0;\n    const origCount = this.count();\n\n    // If filter is already initialized, then we query against only those items already in filter.\n    // This means no index utilization for fields, so hopefully its filtered to a smallish filteredrows.\n    for (let ei = 0, elen = expressionArray.length; ei < elen; ei++) {\n      // we need to branch existing query to run each filter separately and combine results\n      fr = this.branch().find(expressionArray[ei]).filteredrows;\n      frlen = fr.length;\n      // if the find operation did not reduce the initial set, then the initial set is the actual result\n      if (frlen === origCount) {\n        return this;\n      }\n\n      // add any document 'hits'\n      for (fri = 0; fri < frlen; fri++) {\n        idx = fr[fri];\n        if (idxset[idx] === undefined) {\n          idxset[idx] = true;\n          docset.push(idx);\n        }\n      }\n    }\n\n    this.filteredrows = docset;\n    this.filterInitialized = true;\n\n    return this;\n  }\n\n  $or(...args) {\n    return this.findOr(...args);\n  }\n\n  /**\n   * findAnd() - oversee the operation of AND'ed query expressions.\n   *    AND'ed expression evaluation runs each expression progressively against the full collection,\n   *    internally utilizing existing chained resultset functionality.\n   *    Only the first filter can utilize a binary index.\n   *\n   * @param {array} expressionArray - array of expressions\n   * @returns {Resultset} this resultset for further chain ops.\n   */\n  findAnd(expressionArray) {\n    // we have already implementing method chaining in this (our Resultset class)\n    // so lets just progressively apply user supplied and filters\n    for (let i = 0, len = expressionArray.length; i < len; i++) {\n      if (this.count() === 0) {\n        return this;\n      }\n      this.find(expressionArray[i]);\n    }\n    return this;\n  }\n\n  $and(...args) {\n    return this.findAnd(...args);\n  }\n\n  /**\n   * Used for querying via a mongo-style query object.\n   *\n   * @param {object} query - A mongo-style query object used for filtering current results.\n   * @param {boolean=} firstOnly - (Optional) Used by collection.findOne()\n   * @returns {Resultset} this resultset for further chain ops.\n   */\n  find(query, firstOnly) {\n    if (this.collection.data.length === 0) {\n      this.filteredrows = [];\n      this.filterInitialized = true;\n      return this;\n    }\n\n    const queryObject = query || \"getAll\";\n    let p;\n    let property;\n    let queryObjectOp;\n    let obj;\n    let operator;\n    let value;\n    let key;\n    let searchByIndex = false;\n    let result = [];\n    let filters = [];\n    let index = null;\n\n    // flag if this was invoked via findOne()\n    firstOnly = firstOnly || false;\n\n    if (typeof queryObject === \"object\") {\n      for (p in queryObject) {\n        obj = {};\n        obj[p] = queryObject[p];\n        filters.push(obj);\n\n        if (queryObject[p] !== undefined) {\n          property = p;\n          queryObjectOp = queryObject[p];\n        }\n      }\n      // if more than one expression in single query object,\n      // convert implicit $and to explicit $and\n      if (filters.length > 1) {\n        return this.find({\"$and\": filters}, firstOnly);\n      }\n    }\n\n    // apply no filters if they want all\n    if (!property || queryObject === \"getAll\") {\n      if (firstOnly) {\n        this.filteredrows = (this.collection.data.length > 0) ? [0] : [];\n        this.filterInitialized = true;\n      }\n      return this;\n    }\n\n    // injecting $and and $or expression tree evaluation here.\n    if (property === \"$and\" || property === \"$or\") {\n      this[property](queryObjectOp);\n\n      // for chained find with firstonly,\n      if (firstOnly && this.filteredrows.length > 1) {\n        this.filteredrows = this.filteredrows.slice(0, 1);\n      }\n\n      return this;\n    }\n\n    // see if query object is in shorthand mode (assuming eq operator)\n    if (queryObjectOp === null || (typeof queryObjectOp !== \"object\" || queryObjectOp instanceof Date)) {\n      operator = \"$eq\";\n      value = queryObjectOp;\n    } else if (typeof queryObjectOp === \"object\") {\n      for (key in queryObjectOp) {\n        if (queryObjectOp[key] !== undefined) {\n          operator = key;\n          value = queryObjectOp[key];\n          break;\n        }\n      }\n    } else {\n      throw new Error(\"Do not know what you want to do.\");\n    }\n\n    // for regex ops, precompile\n    if (operator === \"$regex\") {\n      if (Array.isArray(value)) {\n        value = new RegExp(value[0], value[1]);\n      } else if (!(value instanceof RegExp)) {\n        value = new RegExp(value);\n      }\n    }\n\n    if (query.query) {\n      let res = this.collection._fullTextSearch.search(query);\n      let docIds = Object.keys(res);\n      let results = [];\n      for (let i = 0; i < docIds.length; i++) {\n        let docId = parseInt(docIds[i]);\n        for (let j = 0; j < this.collection.data.length; j++) {\n          if (this.collection.data[j].$loki === docId) {\n            results.push(this.collection.data[j]);\n          }\n        }\n      }\n      return results;\n    }\n\n    // if user is deep querying the object such as find('name.first': 'odin')\n    const usingDotNotation = (property.indexOf(\".\") !== -1);\n\n    // if an index exists for the property being queried against, use it\n    // for now only enabling where it is the first filter applied and prop is indexed\n    var doIndexCheck = !usingDotNotation && !this.filterInitialized;\n\n    if (doIndexCheck && this.collection.binaryIndices[property] && indexedOps[operator]) {\n      // this is where our lazy index rebuilding will take place\n      // basically we will leave all indexes dirty until we need them\n      // so here we will rebuild only the index tied to this property\n      // ensureIndex() will only rebuild if flagged as dirty since we are not passing force=true param\n      if (this.collection.adaptiveBinaryIndices !== true) {\n        this.collection.ensureIndex(property);\n      }\n\n      searchByIndex = true;\n      index = this.collection.binaryIndices[property];\n    }\n\n    // the comparison function\n    const fun = LokiOps[operator];\n\n    // \"shortcut\" for collection data\n    const t = this.collection.data;\n\n    // filter data length\n    let i = 0;\n\n    let len = 0;\n\n    // Query executed differently depending on :\n    //    - whether the property being queried has an index defined\n    //    - if chained, we handle first pass differently for initial filteredrows[] population\n    //\n    // For performance reasons, each case has its own if block to minimize in-loop calculations\n\n    let filter;\n\n    let rowIdx = 0;\n\n    // If the filteredrows[] is already initialized, use it\n    if (this.filterInitialized) {\n      filter = this.filteredrows;\n      len = filter.length;\n\n      // currently supporting dot notation for non-indexed conditions only\n      if (usingDotNotation) {\n        property = property.split(\".\");\n        for (i = 0; i < len; i++) {\n          rowIdx = filter[i];\n          if (dotSubScan(t[rowIdx], property, fun, value)) {\n            result.push(rowIdx);\n          }\n        }\n      } else {\n        for (i = 0; i < len; i++) {\n          rowIdx = filter[i];\n          if (fun(t[rowIdx][property], value)) {\n            result.push(rowIdx);\n          }\n        }\n      }\n    }\n    // first chained query so work against data[] but put results in filteredrows\n    else {\n      // if not searching by index\n      if (!searchByIndex) {\n        len = t.length;\n\n        if (usingDotNotation) {\n          property = property.split(\".\");\n          for (i = 0; i < len; i++) {\n            if (dotSubScan(t[i], property, fun, value)) {\n              result.push(i);\n              if (firstOnly) {\n                this.filteredrows = result;\n                this.filterInitialized = true;\n                return this;\n              }\n            }\n          }\n        } else {\n          for (i = 0; i < len; i++) {\n            if (fun(t[i][property], value)) {\n              result.push(i);\n              if (firstOnly) {\n                this.filteredrows = result;\n                this.filterInitialized = true;\n                return this;\n              }\n            }\n          }\n        }\n      } else {\n        // search by index\n        const segm = this.collection.calculateRange(operator, property, value);\n\n        if (operator !== \"$in\") {\n          for (i = segm[0]; i <= segm[1]; i++) {\n            if (indexedOps[operator] !== true) {\n              // must be a function, implying 2nd phase filtering of results from calculateRange\n              if (indexedOps[operator](t[index.values[i]][property], value)) {\n                result.push(index.values[i]);\n                if (firstOnly) {\n                  this.filteredrows = result;\n                  this.filterInitialized = true;\n                  return this;\n                }\n              }\n            }\n            else {\n              result.push(index.values[i]);\n              if (firstOnly) {\n                this.filteredrows = result;\n                this.filterInitialized = true;\n                return this;\n              }\n            }\n          }\n        } else {\n          for (i = 0, len = segm.length; i < len; i++) {\n            result.push(index.values[segm[i]]);\n            if (firstOnly) {\n              this.filteredrows = result;\n              this.filterInitialized = true;\n              return this;\n            }\n          }\n        }\n      }\n    }\n\n    this.filteredrows = result;\n    this.filterInitialized = true; // next time work against filteredrows[]\n    return this;\n  }\n\n\n  /**\n   * where() - Used for filtering via a javascript filter function.\n   *\n   * @param {function} fun - A javascript function used for filtering current results by.\n   * @returns {Resultset} this resultset for further chain ops.\n   */\n  where(fun) {\n    let viewFunction;\n    let result = [];\n\n    if (\"function\" === typeof fun) {\n      viewFunction = fun;\n    } else {\n      throw new TypeError(\"Argument is not a stored view or a function\");\n    }\n    try {\n      // If the filteredrows[] is already initialized, use it\n      if (this.filterInitialized) {\n        let j = this.filteredrows.length;\n\n        while (j--) {\n          if (viewFunction(this.collection.data[this.filteredrows[j]]) === true) {\n            result.push(this.filteredrows[j]);\n          }\n        }\n\n        this.filteredrows = result;\n\n        return this;\n      }\n      // otherwise this is initial chained op, work against data, push into filteredrows[]\n      else {\n        let k = this.collection.data.length;\n\n        while (k--) {\n          if (viewFunction(this.collection.data[k]) === true) {\n            result.push(k);\n          }\n        }\n\n        this.filteredrows = result;\n        this.filterInitialized = true;\n\n        return this;\n      }\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  /**\n   * count() - returns the number of documents in the resultset.\n   *\n   * @returns {number} The number of documents in the resultset.\n   */\n  count() {\n    if (this.filterInitialized) {\n      return this.filteredrows.length;\n    }\n    return this.collection.count();\n  }\n\n  /**\n   * Terminates the chain and returns array of filtered documents\n   * @param {boolean} forceClones - Allows forcing the return of cloned objects even when\n   *        the collection is not configured for clone object.\n   * @param {string} forceCloneMethod - Allows overriding the default or collection specified cloning method.\n   *        Possible values include 'parse-stringify', 'jquery-extend-deep', and 'shallow'\n   * @param {boolean} removeMeta - Will force clones and strip $loki and meta properties from documents\n   *\n   * @returns {array} Array of documents in the resultset\n   */\n  data({forceClones, forceCloneMethod = this.collection.cloneMethod, removeMeta = false} = {}) {\n    let result = [];\n    let data = this.collection.data;\n    let obj;\n    let len;\n    let i;\n    let method;\n\n    // if user opts to strip meta, then force clones and use 'shallow' if 'force' options are not present\n    if (removeMeta && !forceClones) {\n      forceClones = true;\n      forceCloneMethod = \"shallow\";\n    }\n\n    // if this has no filters applied, just return collection.data\n    if (!this.filterInitialized) {\n      if (this.filteredrows.length === 0) {\n        // determine whether we need to clone objects or not\n        if (this.collection.cloneObjects || forceClones) {\n          len = data.length;\n          method = forceCloneMethod;\n\n          for (i = 0; i < len; i++) {\n            obj = clone(data[i], method);\n            if (removeMeta) {\n              delete obj.$loki;\n              delete obj.meta;\n            }\n            result.push(obj);\n          }\n          return result;\n        }\n        // otherwise we are not cloning so return sliced array with same object references\n        else {\n          return data.slice();\n        }\n      } else {\n        // filteredrows must have been set manually, so use it\n        this.filterInitialized = true;\n      }\n    }\n\n    const fr = this.filteredrows;\n    len = fr.length;\n\n    if (this.collection.cloneObjects || forceClones) {\n      method = forceCloneMethod;\n      for (i = 0; i < len; i++) {\n        obj = clone(data[fr[i]], method);\n        if (removeMeta) {\n          delete obj.$loki;\n          delete obj.meta;\n        }\n        result.push(obj);\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        result.push(data[fr[i]]);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Used to run an update operation on all documents currently in the resultset.\n   *\n   * @param {function} updateFunction - User supplied updateFunction(obj) will be executed for each document object.\n   * @returns {Resultset} this resultset for further chain ops.\n   */\n  update(updateFunction) {\n    if (typeof(updateFunction) !== \"function\") {\n      throw new TypeError(\"Argument is not a function\");\n    }\n\n    // if this has no filters applied, we need to populate filteredrows first\n    if (!this.filterInitialized && this.filteredrows.length === 0) {\n      this.filteredrows = this.collection.prepareFullDocIndex();\n    }\n\n    const len = this.filteredrows.length;\n    const rcd = this.collection.data;\n\n    for (let idx = 0; idx < len; idx++) {\n      // pass in each document object currently in resultset to user supplied updateFunction\n      updateFunction(rcd[this.filteredrows[idx]]);\n\n      // notify collection we have changed this object so it can update meta and allow DynamicViews to re-evaluate\n      this.collection.update(rcd[this.filteredrows[idx]]);\n    }\n\n    return this;\n  }\n\n  /**\n   * Removes all document objects which are currently in resultset from collection (as well as resultset)\n   *\n   * @returns {Resultset} this (empty) resultset for further chain ops.\n   */\n  remove() {\n\n    // if this has no filters applied, we need to populate filteredrows first\n    if (!this.filterInitialized && this.filteredrows.length === 0) {\n      this.filteredrows = this.collection.prepareFullDocIndex();\n    }\n\n    this.collection.remove(this.data());\n\n    this.filteredrows = [];\n\n    return this;\n  }\n\n  /**\n   * data transformation via user supplied functions\n   *\n   * @param {function} mapFunction - this function accepts a single document for you to transform and return\n   * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n   * @returns {value} The output of your reduceFunction\n   */\n  mapReduce(mapFunction, reduceFunction) {\n    try {\n      return reduceFunction(this.data().map(mapFunction));\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  /**\n   * eqJoin() - Left joining two sets of data. Join keys can be defined or calculated properties\n   * eqJoin expects the right join key values to be unique.  Otherwise left data will be joined on the last joinData object with that key\n   * @param {Array} joinData - Data array to join to.\n   * @param {(string|function)} leftJoinKey - Property name in this result set to join on or a function to produce a value to join on\n   * @param {(string|function)} rightJoinKey - Property name in the joinData to join on or a function to produce a value to join on\n   * @param {function=} mapFun - (Optional) A function that receives each matching pair and maps them into output objects - function(left,right){return joinedObject}\n   * @returns {Resultset} A resultset with data in the format [{left: leftObj, right: rightObj}]\n   */\n  eqJoin(joinData, leftJoinKey, rightJoinKey, mapFun) {\n    let leftData = [];\n    let leftDataLength;\n    let rightData = [];\n    let rightDataLength;\n    let key;\n    let result = [];\n    let leftKeyisFunction = typeof leftJoinKey === \"function\";\n    let rightKeyisFunction = typeof rightJoinKey === \"function\";\n    let joinMap = {};\n\n    //get the left data\n    leftData = this.data();\n    leftDataLength = leftData.length;\n\n    //get the right data\n    if (joinData instanceof Resultset) {\n      rightData = joinData.data();\n    } else if (Array.isArray(joinData)) {\n      rightData = joinData;\n    } else {\n      throw new TypeError(\"joinData needs to be an array or result set\");\n    }\n    rightDataLength = rightData.length;\n\n    //construct a lookup table\n    for (let i = 0; i < rightDataLength; i++) {\n      key = rightKeyisFunction ? rightJoinKey(rightData[i]) : rightData[i][rightJoinKey];\n      joinMap[key] = rightData[i];\n    }\n\n    if (!mapFun) {\n      mapFun = (left, right) => ({\n        left,\n        right\n      });\n    }\n\n    //Run map function over each object in the resultset\n    for (let j = 0; j < leftDataLength; j++) {\n      key = leftKeyisFunction ? leftJoinKey(leftData[j]) : leftData[j][leftJoinKey];\n      result.push(mapFun(leftData[j], joinMap[key] || {}));\n    }\n\n    //return a new resultset with no filters\n    this.collection = new Collection(\"joinData\");\n    this.collection.insert(result);\n    this.filteredrows = [];\n    this.filterInitialized = false;\n\n    return this;\n  }\n\n  map(mapFun) {\n    let data = this.data().map(mapFun);\n    //return return a new resultset with no filters\n    this.collection = new Collection(\"mappedData\");\n    this.collection.insert(data);\n    this.filteredrows = [];\n    this.filterInitialized = false;\n\n    return this;\n  }\n\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/loki/src/resultset.js\n// module id = 3\n// module chunks = 0","/* global jQuery */\nexport function clone(data, method) {\n  if (data === null || data === undefined) {\n    return null;\n  }\n\n  const cloneMethod = method || \"parse-stringify\";\n  let cloned;\n\n  switch (cloneMethod) {\n    case \"parse-stringify\":\n      cloned = JSON.parse(JSON.stringify(data));\n      break;\n    case \"jquery-extend-deep\":\n      cloned = jQuery.extend(true, {}, data);\n      break;\n    case \"shallow\":\n      // more compatible method for older browsers\n      cloned = data.prototype ? Object.create(data.prototype) : {};\n      Object.keys(data).map((i) => {\n        cloned[i] = data[i];\n      });\n      break;\n    case \"shallow-assign\":\n      // should be supported by newer environments/browsers\n      cloned = data.prototype ? Object.create(data.prototype) : {};\n      Object.assign(cloned, data);\n      break;\n    default:\n      break;\n  }\n\n  return cloned;\n}\n\nexport function cloneObjectArray(objarray, method) {\n  let i;\n  const result = [];\n\n  if (method === \"parse-stringify\") {\n    return clone(objarray, method);\n  }\n\n  i = objarray.length - 1;\n\n  for (; i <= 0; i--) {\n    result.push(clone(objarray[i], method));\n  }\n\n  return result;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/loki/src/clone.js\n// module id = 4\n// module chunks = 0","/**\n * Created by toni on 1/27/17.\n */\nexport function copyProperties(src, dest) {\n  let prop;\n  for (prop in src) {\n    dest[prop] = src[prop];\n  }\n}\n\n// used to recursively scan hierarchical transform step object for param substitution\nfunction resolveTransformObject(subObj, params, depth) {\n  let prop;\n  let pname;\n\n  if (typeof depth !== \"number\") {\n    depth = 0;\n  }\n\n  if (++depth >= 10) return subObj;\n\n  for (prop in subObj) {\n    if (typeof subObj[prop] === \"string\" && subObj[prop].indexOf(\"[%lktxp]\") === 0) {\n      pname = subObj[prop].substring(8);\n      if (params[pname] !== undefined) {\n        subObj[prop] = params[pname];\n      }\n    } else if (typeof subObj[prop] === \"object\") {\n      subObj[prop] = resolveTransformObject(subObj[prop], params, depth);\n    }\n  }\n\n  return subObj;\n}\n// top level utility to resolve an entire (single) transform (array of steps) for parameter substitution\nexport function resolveTransformParams(transform, params) {\n  let idx;\n  let clonedStep;\n  const resolvedTransform = [];\n\n  if (typeof params === \"undefined\") return transform;\n\n  // iterate all steps in the transform array\n  for (idx = 0; idx < transform.length; idx++) {\n    // clone transform so our scan and replace can operate directly on cloned transform\n    clonedStep = JSON.parse(JSON.stringify(transform[idx]));\n    resolvedTransform.push(resolveTransformObject(clonedStep, params));\n  }\n\n  return resolvedTransform;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/loki/src/utils.js\n// module id = 5\n// module chunks = 0","/** Helper function for determining 'loki' abstract equality which is a little more abstract than ==\n *     aeqHelper(5, '5') === true\n *     aeqHelper(5.0, '5') === true\n *     aeqHelper(new Date(\"1/1/2011\"), new Date(\"1/1/2011\")) === true\n *     aeqHelper({a:1}, {z:4}) === true (all objects sorted equally)\n *     aeqHelper([1, 2, 3], [1, 3]) === false\n *     aeqHelper([1, 2, 3], [1, 2, 3]) === true\n *     aeqHelper(undefined, null) === true\n */\nexport function aeqHelper(prop1, prop2) {\n  let cv1;\n  let cv2;\n  let t1;\n  let t2;\n\n  if (prop1 === prop2) return true;\n\n  // 'falsy' and Boolean handling\n  if (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {\n    // dates and NaN conditions (typed dates before serialization)\n    switch (prop1) {\n      case undefined:\n        t1 = 1;\n        break;\n      case null:\n        t1 = 1;\n        break;\n      case false:\n        t1 = 3;\n        break;\n      case true:\n        t1 = 4;\n        break;\n      case \"\":\n        t1 = 5;\n        break;\n      default:\n        t1 = (prop1 === prop1) ? 9 : 0;\n        break;\n    }\n\n    switch (prop2) {\n      case undefined:\n        t2 = 1;\n        break;\n      case null:\n        t2 = 1;\n        break;\n      case false:\n        t2 = 3;\n        break;\n      case true:\n        t2 = 4;\n        break;\n      case \"\":\n        t2 = 5;\n        break;\n      default:\n        t2 = (prop2 === prop2) ? 9 : 0;\n        break;\n    }\n\n    // one or both is edge case\n    if (t1 !== 9 || t2 !== 9) {\n      return (t1 === t2);\n    }\n  }\n\n  // Handle 'Number-like' comparisons\n  cv1 = Number(prop1);\n  cv2 = Number(prop2);\n\n  // if one or both are 'number-like'...\n  if (cv1 === cv1 || cv2 === cv2) {\n    return (cv1 === cv2);\n  }\n\n  // not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n  cv1 = prop1.toString();\n  cv2 = prop2.toString();\n\n  return (cv1 == cv2);\n}\n\n/** Helper function for determining 'less-than' conditions for ops, sorting, and binary indices.\n *     In the future we might want $lt and $gt ops to use their own functionality/helper.\n *     Since binary indices on a property might need to index [12, NaN, new Date(), Infinity], we\n *     need this function (as well as gtHelper) to always ensure one value is LT, GT, or EQ to another.\n */\nexport function ltHelper(prop1, prop2, equal) {\n  let cv1;\n  let cv2;\n  let t1;\n  let t2;\n\n  // if one of the params is falsy or strictly true or not equal to itself\n  // 0, 0.0, \"\", NaN, null, undefined, not defined, false, true\n  if (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {\n    switch (prop1) {\n      case undefined:\n        t1 = 1;\n        break;\n      case null:\n        t1 = 1;\n        break;\n      case false:\n        t1 = 3;\n        break;\n      case true:\n        t1 = 4;\n        break;\n      case \"\":\n        t1 = 5;\n        break;\n        // if strict equal probably 0 so sort higher, otherwise probably NaN so sort lower than even null\n      default:\n        t1 = (prop1 === prop1) ? 9 : 0;\n        break;\n    }\n\n    switch (prop2) {\n      case undefined:\n        t2 = 1;\n        break;\n      case null:\n        t2 = 1;\n        break;\n      case false:\n        t2 = 3;\n        break;\n      case true:\n        t2 = 4;\n        break;\n      case \"\":\n        t2 = 5;\n        break;\n      default:\n        t2 = (prop2 === prop2) ? 9 : 0;\n        break;\n    }\n\n    // one or both is edge case\n    if (t1 !== 9 || t2 !== 9) {\n      return (t1 === t2) ? equal : (t1 < t2);\n    }\n  }\n\n  // if both are numbers (string encoded or not), compare as numbers\n  cv1 = Number(prop1);\n  cv2 = Number(prop2);\n\n  if (cv1 === cv1 && cv2 === cv2) {\n    if (cv1 < cv2) return true;\n    if (cv1 > cv2) return false;\n    return equal;\n  }\n\n  if (cv1 === cv1 && cv2 !== cv2) {\n    return true;\n  }\n\n  if (cv2 === cv2 && cv1 !== cv1) {\n    return false;\n  }\n\n  if (prop1 < prop2) return true;\n  if (prop1 > prop2) return false;\n  if (prop1 == prop2) return equal;\n\n  // not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n  cv1 = prop1.toString();\n  cv2 = prop2.toString();\n\n  if (cv1 < cv2) {\n    return true;\n  }\n\n  if (cv1 == cv2) {\n    return equal;\n  }\n\n  return false;\n}\n\nexport function gtHelper(prop1, prop2, equal) {\n  let cv1;\n  let cv2;\n  let t1;\n  let t2;\n\n  // 'falsy' and Boolean handling\n  if (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {\n    switch (prop1) {\n      case undefined:\n        t1 = 1;\n        break;\n      case null:\n        t1 = 1;\n        break;\n      case false:\n        t1 = 3;\n        break;\n      case true:\n        t1 = 4;\n        break;\n      case \"\":\n        t1 = 5;\n        break;\n        // NaN 0\n      default:\n        t1 = (prop1 === prop1) ? 9 : 0;\n        break;\n    }\n\n    switch (prop2) {\n      case undefined:\n        t2 = 1;\n        break;\n      case null:\n        t2 = 1;\n        break;\n      case false:\n        t2 = 3;\n        break;\n      case true:\n        t2 = 4;\n        break;\n      case \"\":\n        t2 = 5;\n        break;\n      default:\n        t2 = (prop2 === prop2) ? 9 : 0;\n        break;\n    }\n\n    // one or both is edge case\n    if (t1 !== 9 || t2 !== 9) {\n      return (t1 === t2) ? equal : (t1 > t2);\n    }\n  }\n\n  // if both are numbers (string encoded or not), compare as numbers\n  cv1 = Number(prop1);\n  cv2 = Number(prop2);\n  if (cv1 === cv1 && cv2 === cv2) {\n    if (cv1 > cv2) return true;\n    if (cv1 < cv2) return false;\n    return equal;\n  }\n\n  if (cv1 === cv1 && cv2 !== cv2) {\n    return false;\n  }\n\n  if (cv2 === cv2 && cv1 !== cv1) {\n    return true;\n  }\n\n  if (prop1 > prop2) return true;\n  if (prop1 < prop2) return false;\n  if (prop1 == prop2) return equal;\n\n  // not strict equal nor less than nor gt so must be dates or mixed types\n  // convert to string and use that to compare\n  cv1 = prop1.toString();\n  cv2 = prop2.toString();\n\n  if (cv1 > cv2) {\n    return true;\n  }\n\n  if (cv1 == cv2) {\n    return equal;\n  }\n\n  return false;\n}\n\nexport function sortHelper(prop1, prop2, desc) {\n  if (aeqHelper(prop1, prop2)) return 0;\n\n  if (ltHelper(prop1, prop2, false)) {\n    return (desc) ? (1) : (-1);\n  }\n\n  if (gtHelper(prop1, prop2, false)) {\n    return (desc) ? (-1) : (1);\n  }\n\n  // not lt, not gt so implied equality-- date compatible\n  return 0;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/loki/src/helper.js\n// module id = 6\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 7\n// module chunks = 0","export class UniqueIndex {\n\n  constructor(uniqueField) {\n    this.field = uniqueField;\n    this.keyMap = {};\n    this.lokiMap = {};\n  }\n\n  set(obj) {\n    const fieldValue = obj[this.field];\n    if (fieldValue !== null && typeof(fieldValue) !== \"undefined\") {\n      if (this.keyMap[fieldValue]) {\n        throw new Error(\"Duplicate key for property \" + this.field + \": \" + fieldValue);\n      } else {\n        this.keyMap[fieldValue] = obj;\n        this.lokiMap[obj.$loki] = fieldValue;\n      }\n    }\n  }\n\n  get(key) {\n    return this.keyMap[key];\n  }\n\n  byId(id) {\n    return this.keyMap[this.lokiMap[id]];\n  }\n\n  /**\n\t * Updates a document's unique index given an updated object.\n\t * @param  {Object} obj Original document object\n\t * @param  {Object} doc New document object (likely the same as obj)\n\t */\n  update(obj, doc) {\n    if (this.lokiMap[obj.$loki] !== doc[this.field]) {\n      const old = this.lokiMap[obj.$loki];\n      this.set(doc);\n      // make the old key fail bool test, while avoiding the use of delete (mem-leak prone)\n      this.keyMap[old] = undefined;\n    } else {\n      this.keyMap[obj[this.field]] = doc;\n    }\n  }\n\n  remove(key) {\n    const obj = this.keyMap[key];\n    if (obj !== null && typeof obj !== \"undefined\") {\n      this.keyMap[key] = undefined;\n      this.lokiMap[obj.$loki] = undefined;\n    } else {\n      throw new Error(\"Key is not in unique index: \" + this.field);\n    }\n  }\n\n  clear() {\n    this.keyMap = {};\n    this.lokiMap = {};\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/loki/src/unique_index.js\n// module id = 8\n// module chunks = 0","export class ExactIndex {\n\n  constructor(exactField) {\n    this.index = {};\n    this.field = exactField;\n  }\n\n  // add the value you want returned to the key in the index\n  set(key, val) {\n    if (this.index[key]) {\n      this.index[key].push(val);\n    } else {\n      this.index[key] = [val];\n    }\n  }\n\n  // remove the value from the index, if the value was the last one, remove the key\n  remove(key, val) {\n    const idxSet = this.index[key];\n    for (const i in idxSet) {\n      if (idxSet[i] === val) {\n        idxSet.splice(i, 1);\n      }\n    }\n    if (idxSet.length < 1) {\n      this.index[key] = undefined;\n    }\n  }\n\n  // get the values related to the key, could be more than one\n  get(key) {\n    return this.index[key];\n  }\n\n  // clear will zap the index\n  clear() {\n    this.index = {};\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/loki/src/exact_index.js\n// module id = 9\n// module chunks = 0","import {LokiEventEmitter} from \"./event_emitter\";\nimport {Resultset} from \"./resultset\";\n\n/*\n applySortCriteria -> like Resultset::compoundsort\n\n queueRebuildEvent -> Promise?\n */\n\n/**\n * DynamicView class is a versatile 'live' view class which can have filters and sorts applied.\n *    Collection.addDynamicView(name) instantiates this DynamicView object and notifies it\n *    whenever documents are add/updated/removed so it can remain up-to-date. (chainable)\n *\n * @example\n * let mydv = mycollection.addDynamicView('test');  // default is non-persistent\n * mydv.applyFind({ 'doors' : 4 });\n * mydv.applyWhere(function(obj) { return obj.name === 'Toyota'; });\n * let results = mydv.data();\n *\n * @extends LokiEventEmitter\n\n * @see {@link Collection#addDynamicView} to construct instances of DynamicView\n */\nexport class DynamicView extends LokiEventEmitter {\n\n  /**\n   * Constructor.\n   * @param {Collection} collection - a reference to the collection to work agains\n   * @param {string} name - the name of this dynamic view\n   * @param {boolean} [persistent=false] - indicates if view is to main internal results array in 'resultdata'\n   * @param {string} [sortPriority='passive'] - 'passive' (sorts performed on call to data) or 'active' (after updates)\n   * @param {number} [minRebuildInterval=1] - minimum rebuild interval (need clarification to docs here)\n   */\n  constructor(collection, name, {\n    persistent = false,\n    sortPriority = \"passive\",\n    minRebuildInterval = 1\n  } = {}) {\n    super();\n    this._collection = collection;\n    this.name = name;\n    this._rebuildPending = false;\n    this._persistent = persistent;\n    // 'passive' will defer the sort phase until they call data(). (most efficient overall)\n    // 'active' will sort async whenever next idle. (prioritizes read speeds)\n    this._sortPriority = sortPriority;\n    this._minRebuildInterval = minRebuildInterval;\n\n    this._resultset = new Resultset(collection);\n    this._resultsdata = [];\n    this._resultsdirty = false;\n\n    this.cachedresultset = null;\n\n    // keep ordered filter pipeline\n    this._filterPipeline = [];\n\n    // sorting member variables\n    // we only support one active search, applied using applySort() or applySimpleSort()\n    this._sortFunction = null;\n    this._sortCriteria = null;\n    this._sortDirty = false;\n\n    // for now just have 1 event for when we finally rebuilt lazy view\n    // once we refactor transactions, i will tie in certain transactional events\n\n    this.events = {\n      \"rebuild\": []\n    };\n  }\n\n  /**\n   * rematerialize() - intended for use immediately after deserialization (loading)\n   *    This will clear out and reapply filterPipeline ops, recreating the view.\n   *    Since where filters do not persist correctly, this method allows\n   *    restoring the view to state where user can re-apply those where filters.\n   *\n   * @param removeWhereFilters\n   * @returns {DynamicView} This dynamic view for further chained ops.\n   * @fires DynamicView.rebuild\n   */\n  rematerialize({removeWhereFilters = undefined}) {\n    let fpl;\n    let fpi;\n    let idx;\n\n    this._resultdata = [];\n    this._resultsdirty = true;\n    this._resultset = new Resultset(this._collection);\n\n    if (this._sortFunction || this._sortCriteria) {\n      this._sortDirty = true;\n    }\n\n    if (removeWhereFilters !== undefined) {\n      // for each view see if it had any where filters applied... since they don't\n      // serialize those functions lets remove those invalid filters\n      fpl = this._filterPipeline.length;\n      fpi = fpl;\n      while (fpi--) {\n        if (this._filterPipeline[fpi].type === \"where\") {\n          if (fpi !== this._filterPipeline.length - 1) {\n            this._filterPipeline[fpi] = this._filterPipeline[this._filterPipeline.length - 1];\n          }\n          this._filterPipeline.length--;\n        }\n      }\n    }\n\n    // back up old filter pipeline, clear filter pipeline, and reapply pipeline ops\n    const ofp = this._filterPipeline;\n    this._filterPipeline = [];\n\n    // now re-apply 'find' filterPipeline ops\n    fpl = ofp.length;\n    for (idx = 0; idx < fpl; idx++) {\n      this.applyFind(ofp[idx].val);\n    }\n\n    // during creation of unit tests, i will remove this forced refresh and leave lazy\n    this.data();\n\n    // emit rebuild event in case user wants to be notified\n    this.emit(\"rebuild\", this);\n\n    return this;\n  }\n\n  /**\n   * branchResultset() - Makes a copy of the internal resultset for branched queries.\n   *    Unlike this dynamic view, the branched resultset will not be 'live' updated,\n   *    so your branched query should be immediately resolved and not held for future evaluation.\n   *\n   * @param {(string|array=)} transform - Optional name of collection transform, or an array of transform steps\n   * @param {object=} parameters - optional parameters (if optional transform requires them)\n   * @returns {Resultset} A copy of the internal resultset for branched queries.\n   */\n  branchResultset(transform, parameters) {\n    const rs = this._resultset.branch();\n\n    if (typeof transform === \"undefined\") {\n      return rs;\n    }\n\n    return rs.transform(transform, parameters);\n  }\n\n  /**\n   * toJSON() - Override of toJSON to avoid circular references\n   *\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      _persistent: this._persistent,\n      _sortPriority: this._sortPriority,\n      _minRebuildInterval: this._minRebuildInterval,\n      _resultset: this._resultset,\n      _resultsdirty: true,\n      _filterPipeline: this._filterPipeline,\n      _sortCriteria: this._sortCriteria,\n      _sortDirty: this._sortDirty,\n    };\n  }\n\n  static fromJSONObject(collection, obj) {\n    let dv = new DynamicView(collection, obj.name, obj.options);\n    dv._resultsdirty = obj._resultsdirty;\n    dv._filterPipeline = obj._filterPipeline;\n    dv.resultdata = [];\n\n    dv._sortCriteria = obj._sortCriteria;\n    dv._sortDirty = obj._sortDirty;\n    dv._resultset.filteredrows = obj._resultset.filteredrows;\n    dv._resultset.filterInitialized = obj._resultset.filterInitialized;\n    dv.rematerialize({\n      removeWhereFilters: true\n    });\n    return dv;\n  }\n\n  /**\n   * removeFilters() - Used to clear pipeline and reset dynamic view to initial state.\n   *     Existing options should be retained.\n   * @param {boolean=} queueSortPhase - (default: false) if true we will async rebuild view (maybe set default to true in future?)\n   */\n  removeFilters({queueSortPhase = false} = {}) {\n    this._rebuildPending = false;\n    this._resultset.reset();\n    this._resultdata = [];\n    this._resultsdirty = true;\n\n    this.cachedresultset = null;\n\n    // keep ordered filter pipeline\n    this._filterPipeline = [];\n\n    // sorting member variables\n    // we only support one active search, applied using applySort() or applySimpleSort()\n    this._sortFunction = null;\n    this._sortCriteria = null;\n    this._sortDirty = false;\n\n    if (queueSortPhase === true) {\n      this.queueSortPhase();\n    }\n  }\n\n  /**\n   * applySort() - Used to apply a sort to the dynamic view\n   * @example\n   * dv.applySort(function(obj1, obj2) {\n\t *   if (obj1.name === obj2.name) return 0;\n\t *   if (obj1.name > obj2.name) return 1;\n\t *   if (obj1.name < obj2.name) return -1;\n\t * });\n   *\n   * @param {function} comparefun - a javascript compare function used for sorting\n   * @returns {DynamicView} this DynamicView object, for further chain ops.\n   */\n  applySort(comparefun) {\n    this._sortFunction = comparefun;\n    this._sortCriteria = null;\n\n    this.queueSortPhase();\n\n    return this;\n  }\n\n  /**\n   * applySimpleSort() - Used to specify a property used for view translation.\n   * @example\n   * dv.applySimpleSort(\"name\");\n   *\n   * @param {string} propname - Name of property by which to sort.\n   * @param {boolean=} isdesc - (Optional) If true, the sort will be in descending order.\n   * @returns {DynamicView} this DynamicView object, for further chain ops.\n   */\n  applySimpleSort(propname, isdesc) {\n    this._sortCriteria = [\n      [propname, isdesc || false]\n    ];\n    this._sortFunction = null;\n\n    this.queueSortPhase();\n\n    return this;\n  }\n\n  /**\n   * applySortCriteria() - Allows sorting a resultset based on multiple columns.\n   * @example\n   * // to sort by age and then name (both ascending)\n   * dv.applySortCriteria(['age', 'name']);\n   * // to sort by age (ascending) and then by name (descending)\n   * dv.applySortCriteria(['age', ['name', true]);\n   * // to sort by age (descending) and then by name (descending)\n   * dv.applySortCriteria(['age', true], ['name', true]);\n   *\n   * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n   * @returns {DynamicView} Reference to this DynamicView, sorted, for future chain operations.\n   */\n  applySortCriteria(criteria) {\n    this._sortCriteria = criteria;\n    this._sortFunction = null;\n\n    this.queueSortPhase();\n\n    return this;\n  }\n\n  /**\n   * startTransaction() - marks the beginning of a transaction.\n   *\n   * @returns {DynamicView} this DynamicView object, for further chain ops.\n   */\n  startTransaction() {\n    this.cachedresultset = this._resultset.copy();\n\n    return this;\n  }\n\n  /**\n   * commit() - commits a transaction.\n   *\n   * @returns {DynamicView} this DynamicView object, for further chain ops.\n   */\n  commit() {\n    this.cachedresultset = null;\n\n    return this;\n  }\n\n  /**\n   * rollback() - rolls back a transaction.\n   *\n   * @returns {DynamicView} this DynamicView object, for further chain ops.\n   */\n  rollback() {\n    this._resultset = this.cachedresultset;\n\n    if (this._persistent) {\n      // for now just rebuild the persistent dynamic view data in this worst case scenario\n      // (a persistent view utilizing transactions which get rolled back), we already know the filter so not too bad.\n      this._resultdata = this._resultset.data();\n\n      this.emit(\"rebuild\", this);\n    }\n\n    return this;\n  }\n\n\n  /**\n   * Implementation detail.\n   * _indexOfFilterWithId() - Find the index of a filter in the pipeline, by that filter's ID.\n   *\n   * @param {(string|number)} uid - The unique ID of the filter.\n   * @returns {number}: index of the referenced filter in the pipeline; -1 if not found.\n   */\n  _indexOfFilterWithId(uid) {\n    if (typeof uid === \"string\" || typeof uid === \"number\") {\n      for (let idx = 0, len = this._filterPipeline.length; idx < len; idx += 1) {\n        if (uid === this._filterPipeline[idx].uid) {\n          return idx;\n        }\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Implementation detail.\n   * _addFilter() - Add the filter object to the end of view's filter pipeline and apply the filter to the resultset.\n   *\n   * @param {object} filter - The filter object. Refer to applyFilter() for extra details.\n   */\n  _addFilter(filter) {\n    this._filterPipeline.push(filter);\n    this._resultset[filter.type](filter.val);\n  }\n\n  /**\n   * reapplyFilters() - Reapply all the filters in the current pipeline.\n   *\n   * @returns {DynamicView} this DynamicView object, for further chain ops.\n   */\n  reapplyFilters() {\n    this._resultset.reset();\n\n    this.cachedresultset = null;\n    if (this._persistent) {\n      this._resultdata = [];\n      this._resultsdirty = true;\n    }\n\n    const filters = this._filterPipeline;\n    this._filterPipeline = [];\n\n    for (let idx = 0, len = filters.length; idx < len; idx += 1) {\n      this._addFilter(filters[idx]);\n    }\n\n    if (this._sortFunction || this._sortCriteria) {\n      this.queueSortPhase();\n    } else {\n      this.queueRebuildEvent();\n    }\n\n    return this;\n  }\n\n  /**\n   * applyFilter() - Adds or updates a filter in the DynamicView filter pipeline\n   *\n   * @param {object} filter - A filter object to add to the pipeline.\n   *    The object is in the format { 'type': filter_type, 'val', filter_param, 'uid', optional_filter_id }\n   * @returns {DynamicView} this DynamicView object, for further chain ops.\n   */\n  applyFilter(filter) {\n    const idx = this._indexOfFilterWithId(filter.uid);\n    if (idx >= 0) {\n      this._filterPipeline[idx] = filter;\n      return this.reapplyFilters();\n    }\n\n    this.cachedresultset = null;\n    if (this._persistent) {\n      this._resultdata = [];\n      this._resultsdirty = true;\n    }\n\n    this._addFilter(filter);\n\n    if (this._sortFunction || this._sortCriteria) {\n      this.queueSortPhase();\n    } else {\n      this.queueRebuildEvent();\n    }\n\n    return this;\n  }\n\n  /**\n   * applyFind() - Adds or updates a mongo-style query option in the DynamicView filter pipeline\n   *\n   * @param {object} query - A mongo-style query object to apply to pipeline\n   * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.\n   * @returns {DynamicView} this DynamicView object, for further chain ops.\n   */\n  applyFind(query, uid) {\n    this.applyFilter({\n      type: \"find\",\n      val: query,\n      uid\n    });\n    return this;\n  }\n\n  /**\n   * applyWhere() - Adds or updates a javascript filter function in the DynamicView filter pipeline\n   *\n   * @param {function} fun - A javascript filter function to apply to pipeline\n   * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.\n   * @returns {DynamicView} this DynamicView object, for further chain ops.\n   */\n  applyWhere(fun, uid) {\n    this.applyFilter({\n      type: \"where\",\n      val: fun,\n      uid\n    });\n    return this;\n  }\n\n  /**\n   * removeFilter() - Remove the specified filter from the DynamicView filter pipeline\n   *\n   * @param {(string|number)} uid - The unique ID of the filter to be removed.\n   * @returns {DynamicView} this DynamicView object, for further chain ops.\n   */\n  removeFilter(uid) {\n    const idx = this._indexOfFilterWithId(uid);\n    if (idx < 0) {\n      throw new Error(\"Dynamic view does not contain a filter with ID: \" + uid);\n    }\n\n    this._filterPipeline.splice(idx, 1);\n    this.reapplyFilters();\n    return this;\n  }\n\n  /**\n   * count() - returns the number of documents representing the current DynamicView contents.\n   *\n   * @returns {number} The number of documents representing the current DynamicView contents.\n   */\n  count() {\n    // in order to be accurate we will pay the minimum cost (and not alter dv state management)\n    // recurring resultset data resolutions should know internally its already up to date.\n    // for persistent data this will not update resultdata nor fire rebuild event.\n    if (this._resultsdirty) {\n      this._resultdata = this._resultset.data();\n    }\n\n    return this._resultset.count();\n  }\n\n  /**\n   * data() - resolves and pending filtering and sorting, then returns document array as result.\n   *\n   * @returns {array} An array of documents representing the current DynamicView contents.\n   */\n  data() {\n    // using final sort phase as 'catch all' for a few use cases which require full rebuild\n    if (this._sortDirty || this._resultsdirty) {\n      this.performSortPhase({\n        suppressRebuildEvent: true\n      });\n    }\n    return (this._persistent) ? (this._resultdata) : (this._resultset.data());\n  }\n\n  /**\n   * queueRebuildEvent() - When the view is not sorted we may still wish to be notified of rebuild events.\n   *     This event will throttle and queue a single rebuild event when batches of updates affect the view.\n   */\n  queueRebuildEvent() {\n    if (this._rebuildPending) {\n      return;\n    }\n    this._rebuildPending = true;\n\n    setTimeout(() => {\n      if (this._rebuildPending) {\n        this._rebuildPending = false;\n        this.emit(\"rebuild\", this);\n      }\n    }, this._minRebuildInterval);\n  }\n\n  /**\n   * queueSortPhase : If the view is sorted we will throttle sorting to either :\n   *    (1) passive - when the user calls data(), or\n   *    (2) active - once they stop updating and yield js thread control\n   */\n  queueSortPhase() {\n    // already queued? exit without queuing again\n    if (this._sortDirty) {\n      return;\n    }\n    this._sortDirty = true;\n\n    if (this._sortPriority === \"active\") {\n      // active sorting... once they are done and yield js thread, run async performSortPhase()\n      setTimeout(() => {\n        this.performSortPhase();\n      }, this._minRebuildInterval);\n    } else {\n      // must be passive sorting... since not calling performSortPhase (until data call), lets use queueRebuildEvent to\n      // potentially notify user that data has changed.\n      this.queueRebuildEvent();\n    }\n  }\n\n  /**\n   * performSortPhase() - invoked synchronously or asynchronously to perform final sort phase (if needed)\n   *\n   */\n  performSortPhase(options) {\n    // async call to this may have been pre-empted by synchronous call to data before async could fire\n    if (!this._sortDirty && !this._resultsdirty) {\n      return;\n    }\n\n    options = options || {};\n\n    if (this._sortDirty) {\n      if (this._sortFunction) {\n        this._resultset.sort(this._sortFunction);\n      } else if (this._sortCriteria) {\n        this._resultset.compoundsort(this._sortCriteria);\n      }\n\n      this._sortDirty = false;\n    }\n\n    if (this._persistent) {\n      // persistent view, rebuild local resultdata array\n      this._resultdata = this._resultset.data();\n      this._resultsdirty = false;\n    }\n\n    if (!options.suppressRebuildEvent) {\n      this.emit(\"rebuild\", this);\n    }\n  }\n\n  /**\n   * evaluateDocument() - internal method for (re)evaluating document inclusion.\n   *    Called by : collection.insert() and collection.update().\n   *\n   * @param {int} objIndex - index of document to (re)run through filter pipeline.\n   * @param {bool} isNew - true if the document was just added to the collection.\n   */\n  evaluateDocument(objIndex, isNew) {\n    // if no filter applied yet, the result 'set' should remain 'everything'\n    if (!this._resultset.filterInitialized) {\n      if (this._persistent) {\n        this._resultdata = this._resultset.data();\n      }\n      // need to re-sort to sort new document\n      if (this._sortFunction || this._sortCriteria) {\n        this.queueSortPhase();\n      } else {\n        this.queueRebuildEvent();\n      }\n      return;\n    }\n\n    const ofr = this._resultset.filteredrows;\n    const oldPos = (isNew) ? (-1) : (ofr.indexOf(+objIndex));\n    const oldlen = ofr.length;\n\n    // creating a 1-element resultset to run filter chain ops on to see if that doc passes filters;\n    // mostly efficient algorithm, slight stack overhead price (this function is called on inserts and updates)\n    const evalResultset = new Resultset(this._collection);\n    evalResultset.filteredrows = [objIndex];\n    evalResultset.filterInitialized = true;\n    let filter;\n    for (let idx = 0, len = this._filterPipeline.length; idx < len; idx++) {\n      filter = this._filterPipeline[idx];\n      evalResultset[filter.type](filter.val);\n    }\n\n    // not a true position, but -1 if not pass our filter(s), 0 if passed filter(s)\n    const newPos = (evalResultset.filteredrows.length === 0) ? -1 : 0;\n\n    // wasn't in old, shouldn't be now... do nothing\n    if (oldPos === -1 && newPos === -1) return;\n\n    // wasn't in resultset, should be now... add\n    if (oldPos === -1 && newPos !== -1) {\n      ofr.push(objIndex);\n\n      if (this._persistent) {\n        this._resultdata.push(this._collection.data[objIndex]);\n      }\n\n      // need to re-sort to sort new document\n      if (this._sortFunction || this._sortCriteria) {\n        this.queueSortPhase();\n      } else {\n        this.queueRebuildEvent();\n      }\n\n      return;\n    }\n\n    // was in resultset, shouldn't be now... delete\n    if (oldPos !== -1 && newPos === -1) {\n      if (oldPos < oldlen - 1) {\n        ofr.splice(oldPos, 1);\n\n        if (this._persistent) {\n          this._resultdata.splice(oldPos, 1);\n        }\n      } else {\n        ofr.length = oldlen - 1;\n\n        if (this._persistent) {\n          this._resultdata.length = oldlen - 1;\n        }\n      }\n\n      // in case changes to data altered a sort column\n      if (this._sortFunction || this._sortCriteria) {\n        this.queueSortPhase();\n      } else {\n        this.queueRebuildEvent();\n      }\n      return;\n    }\n\n    // was in resultset, should still be now... (update persistent only?)\n    if (oldPos !== -1 && newPos !== -1) {\n      if (this._persistent) {\n        // in case document changed, replace persistent view data with the latest collection.data document\n        this._resultdata[oldPos] = this._collection.data[objIndex];\n      }\n\n      // in case changes to data altered a sort column\n      if (this._sortFunction || this._sortCriteria) {\n        this.queueSortPhase();\n      } else {\n        this.queueRebuildEvent();\n      }\n    }\n  }\n\n  /**\n   * removeDocument() - internal function called on collection.delete()\n   */\n  removeDocument(objIndex) {\n    // if no filter applied yet, the result 'set' should remain 'everything'\n    if (!this._resultset.filterInitialized) {\n      if (this._persistent) {\n        this._resultdata = this._resultset.data();\n      }\n      // in case changes to data altered a sort column\n      if (this._sortFunction || this._sortCriteria) {\n        this.queueSortPhase();\n      } else {\n        this.queueRebuildEvent();\n      }\n      return;\n    }\n\n    const ofr = this._resultset.filteredrows;\n    const oldPos = ofr.indexOf(+objIndex);\n    let oldlen = ofr.length;\n    let idx;\n\n    if (oldPos !== -1) {\n      // if not last row in resultdata, swap last to hole and truncate last row\n      if (oldPos < oldlen - 1) {\n        ofr[oldPos] = ofr[oldlen - 1];\n        ofr.length = oldlen - 1;\n\n        if (this._persistent) {\n          this._resultdata[oldPos] = this._resultdata[oldlen - 1];\n          this._resultdata.length = oldlen - 1;\n        }\n      }\n      // last row, so just truncate last row\n      else {\n        ofr.length = oldlen - 1;\n\n        if (this._persistent) {\n          this._resultdata.length = oldlen - 1;\n        }\n      }\n\n      // in case changes to data altered a sort column\n      if (this._sortFunction || this._sortCriteria) {\n        this.queueSortPhase();\n      } else {\n        this.queueRebuildEvent();\n      }\n    }\n\n    // since we are using filteredrows to store data array positions\n    // if they remove a document (whether in our view or not),\n    // we need to adjust array positions -1 for all document array references after that position\n    oldlen = ofr.length;\n    for (idx = 0; idx < oldlen; idx++) {\n      if (ofr[idx] > objIndex) {\n        ofr[idx]--;\n      }\n    }\n  }\n\n  /**\n   * mapReduce() - data transformation via user supplied functions\n   *\n   * @param {function} mapFunction - this function accepts a single document for you to transform and return\n   * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n   * @returns The output of your reduceFunction\n   */\n  mapReduce(mapFunction, reduceFunction) {\n    try {\n      return reduceFunction(this.data().map(mapFunction));\n    } catch (err) {\n      throw err;\n    }\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./packages/loki/src/dynamic_view.js\n// module id = 10\n// module chunks = 0"],"sourceRoot":""}